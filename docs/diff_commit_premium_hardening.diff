diff --git a/app-v2/build.gradle.kts b/app-v2/build.gradle.kts
index b34b82c9..ec37a931 100644
--- a/app-v2/build.gradle.kts
+++ b/app-v2/build.gradle.kts
@@ -172,6 +172,7 @@ dependencies {
 
     // v2 Infrastructure
     implementation(project(":infra:logging"))
+    implementation(project(":infra:cache"))
     implementation(project(":infra:tooling"))
     implementation(project(":infra:transport-telegram"))
     implementation(project(":infra:transport-xtream"))
diff --git a/app-v2/src/main/java/com/fishit/player/v2/di/DefaultDebugInfoProvider.kt b/app-v2/src/main/java/com/fishit/player/v2/di/DefaultDebugInfoProvider.kt
index ce7761fe..66020b75 100644
--- a/app-v2/src/main/java/com/fishit/player/v2/di/DefaultDebugInfoProvider.kt
+++ b/app-v2/src/main/java/com/fishit/player/v2/di/DefaultDebugInfoProvider.kt
@@ -1,7 +1,6 @@
 package com.fishit.player.v2.di
 
 import android.content.Context
-import coil3.ImageLoader
 import com.fishit.player.core.catalogsync.SourceActivationStore
 import com.fishit.player.core.catalogsync.SourceId
 import com.fishit.player.core.feature.auth.TelegramAuthRepository
@@ -9,18 +8,15 @@ import com.fishit.player.core.feature.auth.TelegramAuthState
 import com.fishit.player.feature.settings.ConnectionInfo
 import com.fishit.player.feature.settings.ContentCounts
 import com.fishit.player.feature.settings.DebugInfoProvider
+import com.fishit.player.infra.cache.CacheManager
 import com.fishit.player.infra.data.telegram.TelegramContentRepository
 import com.fishit.player.infra.data.xtream.XtreamCatalogRepository
 import com.fishit.player.infra.data.xtream.XtreamLiveRepository
-import com.fishit.player.infra.logging.UnifiedLog
 import com.fishit.player.infra.transport.xtream.XtreamCredentialsStore
 import dagger.hilt.android.qualifiers.ApplicationContext
-import kotlinx.coroutines.Dispatchers
 import kotlinx.coroutines.flow.Flow
 import kotlinx.coroutines.flow.combine
 import kotlinx.coroutines.flow.map
-import kotlinx.coroutines.withContext
-import java.io.File
 import javax.inject.Inject
 import javax.inject.Singleton
 
@@ -29,13 +25,14 @@ import javax.inject.Singleton
  *
  * Provides real system information for DebugViewModel:
  * - Connection status from auth repositories
- * - Cache sizes from file system
+ * - Cache sizes via [CacheManager] (no direct file IO)
  * - Content counts from data repositories
  *
  * **Architecture:**
  * - Lives in app-v2 module (has access to all infra modules)
  * - Injected into DebugViewModel via Hilt
  * - Bridges feature/settings to infra layer
+ * - Delegates all file IO to CacheManager (contract compliant)
  */
 @Singleton
 class DefaultDebugInfoProvider @Inject constructor(
@@ -46,13 +43,11 @@ class DefaultDebugInfoProvider @Inject constructor(
     private val telegramContentRepository: TelegramContentRepository,
     private val xtreamCatalogRepository: XtreamCatalogRepository,
     private val xtreamLiveRepository: XtreamLiveRepository,
-    private val imageLoader: ImageLoader,
+    private val cacheManager: CacheManager
 ) : DebugInfoProvider {
 
     companion object {
         private const val TAG = "DefaultDebugInfoProvider"
-        private const val TDLIB_DB_DIR = "tdlib"
-        private const val TDLIB_FILES_DIR = "tdlib-files"
     }
 
     // =========================================================================
@@ -101,61 +96,22 @@ class DefaultDebugInfoProvider @Inject constructor(
     }
 
     // =========================================================================
-    // Cache Sizes
+    // Cache Sizes - Delegated to CacheManager (no direct file IO)
     // =========================================================================
 
-    override suspend fun getTelegramCacheSize(): Long? = withContext(Dispatchers.IO) {
-        try {
-            // TDLib uses noBackupFilesDir for its data
-            val tdlibDir = File(context.noBackupFilesDir, TDLIB_DB_DIR)
-            val filesDir = File(context.noBackupFilesDir, TDLIB_FILES_DIR)
-            
-            var totalSize = 0L
-            
-            if (tdlibDir.exists()) {
-                totalSize += calculateDirectorySize(tdlibDir)
-            }
-            if (filesDir.exists()) {
-                totalSize += calculateDirectorySize(filesDir)
-            }
-            
-            UnifiedLog.d(TAG) { "TDLib cache size: $totalSize bytes" }
-            totalSize
-        } catch (e: Exception) {
-            UnifiedLog.e(TAG, e) { "Failed to calculate TDLib cache size" }
-            null
-        }
+    override suspend fun getTelegramCacheSize(): Long? {
+        val size = cacheManager.getTelegramCacheSizeBytes()
+        return if (size > 0) size else null
     }
 
-    override suspend fun getImageCacheSize(): Long? = withContext(Dispatchers.IO) {
-        try {
-            // Get Coil disk cache size
-            val diskCache = imageLoader.diskCache
-            val size = diskCache?.size ?: 0L
-            
-            UnifiedLog.d(TAG) { "Image cache size: $size bytes" }
-            size
-        } catch (e: Exception) {
-            UnifiedLog.e(TAG, e) { "Failed to calculate image cache size" }
-            null
-        }
+    override suspend fun getImageCacheSize(): Long? {
+        val size = cacheManager.getImageCacheSizeBytes()
+        return if (size > 0) size else null
     }
 
-    override suspend fun getDatabaseSize(): Long? = withContext(Dispatchers.IO) {
-        try {
-            // ObjectBox stores data in the app's internal storage
-            val objectboxDir = File(context.filesDir, "objectbox")
-            val size = if (objectboxDir.exists()) {
-                calculateDirectorySize(objectboxDir)
-            } else {
-                0L
-            }
-            UnifiedLog.d(TAG) { "Database size: $size bytes" }
-            size
-        } catch (e: Exception) {
-            UnifiedLog.e(TAG, e) { "Failed to calculate database size" }
-            null
-        }
+    override suspend fun getDatabaseSize(): Long? {
+        val size = cacheManager.getDatabaseSizeBytes()
+        return if (size > 0) size else null
     }
 
     // =========================================================================
@@ -183,56 +139,14 @@ class DefaultDebugInfoProvider @Inject constructor(
     }
 
     // =========================================================================
-    // Cache Actions
+    // Cache Actions - Delegated to CacheManager (no direct file IO)
     // =========================================================================
 
-    override suspend fun clearTelegramCache(): Boolean = withContext(Dispatchers.IO) {
-        try {
-            // Only clear files directory, preserve database
-            val filesDir = File(context.noBackupFilesDir, TDLIB_FILES_DIR)
-            
-            if (filesDir.exists()) {
-                deleteDirectoryContents(filesDir)
-                UnifiedLog.i(TAG) { "Cleared TDLib files cache" }
-            }
-            true
-        } catch (e: Exception) {
-            UnifiedLog.e(TAG, e) { "Failed to clear TDLib cache" }
-            false
-        }
-    }
-
-    override suspend fun clearImageCache(): Boolean = withContext(Dispatchers.IO) {
-        try {
-            imageLoader.diskCache?.clear()
-            imageLoader.memoryCache?.clear()
-            UnifiedLog.i(TAG) { "Cleared image cache" }
-            true
-        } catch (e: Exception) {
-            UnifiedLog.e(TAG, e) { "Failed to clear image cache" }
-            false
-        }
+    override suspend fun clearTelegramCache(): Boolean {
+        return cacheManager.clearTelegramCache()
     }
 
-    // =========================================================================
-    // Helper Functions
-    // =========================================================================
-
-    private fun calculateDirectorySize(dir: File): Long {
-        if (!dir.exists()) return 0
-        return dir.walkTopDown()
-            .filter { it.isFile }
-            .sumOf { it.length() }
-    }
-
-    private fun deleteDirectoryContents(dir: File) {
-        if (!dir.exists()) return
-        dir.listFiles()?.forEach { file ->
-            if (file.isDirectory) {
-                file.deleteRecursively()
-            } else {
-                file.delete()
-            }
-        }
+    override suspend fun clearImageCache(): Boolean {
+        return cacheManager.clearImageCache()
     }
 }
diff --git a/docs/diff_commit_3db332ef_type_safe_combine.diff b/docs/diff_commit_3db332ef_type_safe_combine.diff
new file mode 100644
index 00000000..8447ed10
--- /dev/null
+++ b/docs/diff_commit_3db332ef_type_safe_combine.diff
@@ -0,0 +1,634 @@
+diff --git a/docs/diff_commit_c1c14da9_real_debug_data.md b/docs/diff_commit_c1c14da9_real_debug_data.md
+new file mode 100644
+index 00000000..78b97a17
+--- /dev/null
++++ b/docs/diff_commit_c1c14da9_real_debug_data.md
+@@ -0,0 +1,197 @@
++# Diff: Debug Screen Real Data Implementation (c1c14da9)
++
++**Commit:** c1c14da99e719040f768fda5b64c00b37e820412  
++**Date:** 2025-12-22  
++**Author:** karlokarate
++
++## Summary
++
++DebugScreen now displays **REAL data** instead of hardcoded stubs. This commit replaces all demo/stub data in the debug screen with live implementations that query actual system state.
++
++## Changes Overview
++
++| File | Type | Description |
++|------|------|-------------|
++| [LogBufferTree.kt](infra/logging/src/main/java/com/fishit/player/infra/logging/LogBufferTree.kt) | NEW | Timber.Tree with ring buffer for log capture |
++| [LoggingModule.kt](infra/logging/src/main/java/com/fishit/player/infra/logging/di/LoggingModule.kt) | NEW | Hilt module for LogBufferProvider |
++| [UnifiedLogInitializer.kt](infra/logging/src/main/java/com/fishit/player/infra/logging/UnifiedLogInitializer.kt) | MOD | Plant LogBufferTree on init |
++| [DebugInfoProvider.kt](feature/settings/src/main/java/com/fishit/player/feature/settings/DebugInfoProvider.kt) | NEW | Interface for debug info access |
++| [DefaultDebugInfoProvider.kt](app-v2/src/main/java/com/fishit/player/v2/di/DefaultDebugInfoProvider.kt) | NEW | Real implementation with all dependencies |
++| [DebugModule.kt](app-v2/src/main/java/com/fishit/player/v2/di/DebugModule.kt) | NEW | Hilt module for DebugInfoProvider |
++| [DebugViewModel.kt](feature/settings/src/main/java/com/fishit/player/feature/settings/DebugViewModel.kt) | MOD | Use real providers instead of stubs |
++| [build.gradle.kts](infra/logging/build.gradle.kts) | MOD | Add Hilt dependencies |
++
++## What Was Replaced
++
++| Feature | Before (STUB) | After (REAL) |
++|---------|---------------|--------------|
++| **Logs** | `generateDemoLogs()` hardcoded list | `LogBufferProvider.observeLogs()` from Timber |
++| **Telegram Connection** | `telegramConnected = true` | `TelegramAuthRepository.authState` |
++| **Xtream Connection** | `xtreamConnected = false` | `SourceActivationStore.observeStates()` |
++| **Telegram Cache Size** | `"128 MB"` | File system calculation of tdlib directories |
++| **Image Cache Size** | `"45 MB"` | `imageLoader.diskCache?.size` |
++| **Database Size** | `"12 MB"` | ObjectBox directory calculation |
++| **Content Counts** | Hardcoded zeros | Repository `observeAll().map { it.size }` |
++| **Clear Cache** | `delay(1000)` no-op | Real file deletion |
++
++## Architecture
++
++```
++┌─────────────────────────────────────────────────────────────┐
++│  DebugScreen (UI)                                           │
++│    └─ DebugViewModel                                        │
++│         ├─ LogBufferProvider (logs)                         │
++│         ├─ DebugInfoProvider (connection, cache, counts)    │
++│         ├─ SyncStateObserver (sync state) [existing]        │
++│         └─ CatalogSyncWorkScheduler (sync actions) [exist]  │
++└─────────────────────────────────────────────────────────────┘
++                           ↓
++┌─────────────────────────────────────────────────────────────┐
++│  DefaultDebugInfoProvider (app-v2)                          │
++│    ├─ TelegramAuthRepository (connection status)            │
++│    ├─ SourceActivationStore (Xtream status)                 │
++│    ├─ XtreamCredentialsStore (server details)               │
++│    ├─ TelegramContentRepository (media counts)              │
++│    ├─ XtreamCatalogRepository (VOD/Series counts)           │
++│    ├─ XtreamLiveRepository (Live channel counts)            │
++│    └─ ImageLoader (cache size + clearing)                   │
++└─────────────────────────────────────────────────────────────┘
++```
++
++## New Files
++
++### LogBufferTree.kt (215 lines)
++
++```kotlin
++/**
++ * Timber Tree that buffers log entries in a ring buffer.
++ * - Captures all log entries (DEBUG, INFO, WARN, ERROR)
++ * - Maintains fixed-size buffer (default: 500 entries)
++ * - Provides Flow<List<BufferedLogEntry>> for reactive UI
++ */
++class LogBufferTree(maxEntries: Int = 500) : Timber.Tree() {
++    private val buffer = ArrayDeque<BufferedLogEntry>(maxEntries)
++    private val _entriesFlow = MutableStateFlow<List<BufferedLogEntry>>(emptyList())
++    
++    val entriesFlow: Flow<List<BufferedLogEntry>> = _entriesFlow.asStateFlow()
++    
++    override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {
++        // Ring buffer logic: remove oldest if at capacity
++        if (buffer.size >= maxEntries) buffer.removeFirst()
++        buffer.addLast(BufferedLogEntry(timestamp, priority, tag, message, t))
++        _entriesFlow.value = buffer.toList()
++    }
++}
++```
++
++### DebugInfoProvider.kt (118 lines)
++
++```kotlin
++/**
++ * Interface for debug/diagnostics information.
++ * Feature-owned (feature/settings), implementation in app-v2.
++ */
++interface DebugInfoProvider {
++    fun observeTelegramConnection(): Flow<ConnectionInfo>
++    fun observeXtreamConnection(): Flow<ConnectionInfo>
++    suspend fun getTelegramCacheSize(): Long?
++    suspend fun getImageCacheSize(): Long?
++    suspend fun getDatabaseSize(): Long?
++    fun observeContentCounts(): Flow<ContentCounts>
++    suspend fun clearTelegramCache(): Boolean
++    suspend fun clearImageCache(): Boolean
++}
++```
++
++### DefaultDebugInfoProvider.kt (238 lines)
++
++```kotlin
++/**
++ * Real implementation with all dependencies.
++ * Bridges feature/settings to infra layer.
++ */
++@Singleton
++class DefaultDebugInfoProvider @Inject constructor(
++    @ApplicationContext private val context: Context,
++    private val sourceActivationStore: SourceActivationStore,
++    private val telegramAuthRepository: TelegramAuthRepository,
++    private val xtreamCredentialsStore: XtreamCredentialsStore,
++    private val telegramContentRepository: TelegramContentRepository,
++    private val xtreamCatalogRepository: XtreamCatalogRepository,
++    private val xtreamLiveRepository: XtreamLiveRepository,
++    private val imageLoader: ImageLoader,
++) : DebugInfoProvider {
++    // Real implementations using dependencies
++}
++```
++
++## DebugViewModel Changes
++
++**Before:**
++
++```kotlin
++class DebugViewModel @Inject constructor(
++    private val catalogSyncWorkScheduler: CatalogSyncWorkScheduler,
++    private val syncStateObserver: SyncStateObserver,
++    private val tmdbEnrichmentScheduler: TmdbEnrichmentScheduler,
++)
++```
++
++**After:**
++
++```kotlin
++class DebugViewModel @Inject constructor(
++    private val catalogSyncWorkScheduler: CatalogSyncWorkScheduler,
++    private val syncStateObserver: SyncStateObserver,
++    private val tmdbEnrichmentScheduler: TmdbEnrichmentScheduler,
++    private val logBufferProvider: LogBufferProvider,      // NEW
++    private val debugInfoProvider: DebugInfoProvider,      // NEW
++)
++```
++
++**New Init Block:**
++
++```kotlin
++init {
++    loadSystemInfo()
++    observeSyncState()       // existing
++    observeConnectionStatus() // NEW - real auth state
++    observeContentCounts()    // NEW - real counts from repos
++    observeLogs()             // NEW - real logs from buffer
++    loadCacheSizes()          // NEW - real file sizes
++}
++```
++
++## Data Flow
++
++```
++Timber.d("...") → LogBufferTree → entriesFlow → LogBufferProvider 
++                                                      ↓
++                                               DebugViewModel.observeLogs()
++                                                      ↓
++                                               DebugState.recentLogs
++                                                      ↓
++                                               DebugScreen UI
++```
++
++## Contract Compliance
++
++- **LOGGING_CONTRACT_V2:** LogBufferTree integrates with UnifiedLog via Timber
++- **Layer Boundaries:** DebugInfoProvider interface in feature, impl in app-v2
++- **AGENTS.md Section 4:** No direct transport access from feature layer
++
++## Testing Notes
++
++The debug screen will now show:
++
++- Real log entries from the application
++- Actual connection status (disconnected until login)
++- Real cache sizes (0 until files are cached)
++- Real content counts (0 until catalog sync runs)
++
++To verify:
++
++1. Open app → DebugScreen shows "0 MB" for caches, disconnected status
++2. Login to Telegram → Connection shows "Authorized"
++3. Run catalog sync → Content counts increase
++4. Logs section shows real application logs in real-time
+diff --git a/feature/home/build.gradle.kts b/feature/home/build.gradle.kts
+index 3801a09f..533cd383 100644
+--- a/feature/home/build.gradle.kts
++++ b/feature/home/build.gradle.kts
+@@ -63,4 +63,8 @@ dependencies {
+     // Coroutines
+     implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.9.0")
+     implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.9.0")
++    
++    // Test
++    testImplementation("junit:junit:4.13.2")
++    testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:1.9.0")
+ }
+diff --git a/feature/home/src/main/java/com/fishit/player/feature/home/HomeViewModel.kt b/feature/home/src/main/java/com/fishit/player/feature/home/HomeViewModel.kt
+index 800444a7..00f3d615 100644
+--- a/feature/home/src/main/java/com/fishit/player/feature/home/HomeViewModel.kt
++++ b/feature/home/src/main/java/com/fishit/player/feature/home/HomeViewModel.kt
+@@ -58,6 +58,37 @@ data class HomeState(
+                 xtreamSeriesItems.isNotEmpty()
+ }
+ 
++/**
++ * Type-safe container for all home content streams.
++ * 
++ * This ensures that adding/removing a stream later cannot silently break index order.
++ * Each field is strongly typed - no Array<Any?> or index-based access needed.
++ * 
++ * @property continueWatching Items the user has started watching
++ * @property recentlyAdded Recently added items across all sources
++ * @property telegramMedia Telegram media items
++ * @property xtreamVod Xtream VOD items
++ * @property xtreamSeries Xtream series items
++ * @property xtreamLive Xtream live channel items
++ */
++data class HomeContentStreams(
++    val continueWatching: List<HomeMediaItem> = emptyList(),
++    val recentlyAdded: List<HomeMediaItem> = emptyList(),
++    val telegramMedia: List<HomeMediaItem> = emptyList(),
++    val xtreamVod: List<HomeMediaItem> = emptyList(),
++    val xtreamSeries: List<HomeMediaItem> = emptyList(),
++    val xtreamLive: List<HomeMediaItem> = emptyList()
++) {
++    /** True if any content stream has items */
++    val hasContent: Boolean
++        get() = continueWatching.isNotEmpty() ||
++                recentlyAdded.isNotEmpty() ||
++                telegramMedia.isNotEmpty() ||
++                xtreamVod.isNotEmpty() ||
++                xtreamSeries.isNotEmpty() ||
++                xtreamLive.isNotEmpty()
++}
++
+ /**
+  * HomeViewModel - Manages Home screen state
+  *
+@@ -92,39 +123,53 @@ class HomeViewModel @Inject constructor(
+     private val xtreamSeriesItems: Flow<List<HomeMediaItem>> =
+         homeContentRepository.observeXtreamSeries().toHomeItems()
+ 
+-    val state: StateFlow<HomeState> = combine(
++    /**
++     * Type-safe flow combining all content streams.
++     * 
++     * Uses the 4-parameter combine overload (which is type-safe) to aggregate content flows
++     * into HomeContentStreams, preserving strong typing without index access or casts.
++     */
++    private val contentStreams: Flow<HomeContentStreams> = combine(
+         telegramItems,
+         xtreamLiveItems,
+         xtreamVodItems,
+-        xtreamSeriesItems,
++        xtreamSeriesItems
++    ) { telegram, live, vod, series ->
++        HomeContentStreams(
++            continueWatching = emptyList(),  // TODO: Wire up continue watching
++            recentlyAdded = emptyList(),     // TODO: Wire up recently added
++            telegramMedia = telegram,
++            xtreamVod = vod,
++            xtreamSeries = series,
++            xtreamLive = live
++        )
++    }
++
++    /**
++     * Final home state combining content with metadata (errors, sync state, source activation).
++     * 
++     * Uses the 4-parameter combine overload to maintain type safety throughout.
++     * No Array<Any?> values, no index access, no casts.
++     */
++    val state: StateFlow<HomeState> = combine(
++        contentStreams,
+         errorState,
+         syncStateObserver.observeSyncState(),
+         sourceActivationStore.observeStates()
+-    ) { values ->
+-        // Destructure the array of values from combine
+-        @Suppress("UNCHECKED_CAST")
+-        val telegram = values[0] as List<HomeMediaItem>
+-        @Suppress("UNCHECKED_CAST")
+-        val live = values[1] as List<HomeMediaItem>
+-        @Suppress("UNCHECKED_CAST")
+-        val vod = values[2] as List<HomeMediaItem>
+-        @Suppress("UNCHECKED_CAST")
+-        val series = values[3] as List<HomeMediaItem>
+-        val error = values[4] as String?
+-        val syncState = values[5] as SyncUiState
+-        val sourceActivation = values[6] as SourceActivationSnapshot
+-        
++    ) { content, error, syncState, sourceActivation ->
+         HomeState(
+             isLoading = false,
+-            continueWatchingItems = emptyList(),
+-            recentlyAddedItems = emptyList(),
+-            telegramMediaItems = telegram,
+-            xtreamLiveItems = live,
+-            xtreamVodItems = vod,
+-            xtreamSeriesItems = series,
++            continueWatchingItems = content.continueWatching,
++            recentlyAddedItems = content.recentlyAdded,
++            telegramMediaItems = content.telegramMedia,
++            xtreamLiveItems = content.xtreamLive,
++            xtreamVodItems = content.xtreamVod,
++            xtreamSeriesItems = content.xtreamSeries,
+             error = error,
+-            hasTelegramSource = telegram.isNotEmpty(),
+-            hasXtreamSource = listOf(live, vod, series).any { it.isNotEmpty() },
++            hasTelegramSource = content.telegramMedia.isNotEmpty(),
++            hasXtreamSource = content.xtreamVod.isNotEmpty() || 
++                              content.xtreamSeries.isNotEmpty() || 
++                              content.xtreamLive.isNotEmpty(),
+             syncState = syncState,
+             sourceActivation = sourceActivation
+         )
+diff --git a/feature/home/src/test/java/com/fishit/player/feature/home/HomeViewModelCombineSafetyTest.kt b/feature/home/src/test/java/com/fishit/player/feature/home/HomeViewModelCombineSafetyTest.kt
+new file mode 100644
+index 00000000..fb9f09ba
+--- /dev/null
++++ b/feature/home/src/test/java/com/fishit/player/feature/home/HomeViewModelCombineSafetyTest.kt
+@@ -0,0 +1,292 @@
++package com.fishit.player.feature.home
++
++import com.fishit.player.core.model.MediaType
++import com.fishit.player.core.model.SourceType
++import com.fishit.player.feature.home.domain.HomeMediaItem
++import org.junit.Assert.assertEquals
++import org.junit.Assert.assertFalse
++import org.junit.Assert.assertTrue
++import org.junit.Test
++
++/**
++ * Regression tests for [HomeContentStreams] type-safe combine behavior.
++ *
++ * Purpose:
++ * - Verify each list maps to the correct field (no index confusion)
++ * - Verify hasContent logic for single and multiple streams
++ * - Ensure behavior is identical to previous Array<Any?> + cast approach
++ *
++ * These tests validate the Premium Gold refactor that replaced:
++ * ```
++ * combine(...) { values ->
++ *     @Suppress("UNCHECKED_CAST")
++ *     val telegram = values[0] as List<HomeMediaItem>
++ *     ...
++ * }
++ * ```
++ * with type-safe combine:
++ * ```
++ * combine(telegramItems, liveItems, vodItems, seriesItems) { telegram, live, vod, series ->
++ *     HomeContentStreams(telegramMedia = telegram, xtreamLive = live, ...)
++ * }
++ * ```
++ */
++class HomeViewModelCombineSafetyTest {
++
++    // ==================== HomeContentStreams Field Mapping Tests ====================
++
++    @Test
++    fun `HomeContentStreams telegramMedia field contains only telegram items`() {
++        // Given
++        val telegramItems = listOf(
++            createTestItem(id = "tg-1", title = "Telegram Video 1"),
++            createTestItem(id = "tg-2", title = "Telegram Video 2")
++        )
++        
++        // When
++        val streams = HomeContentStreams(telegramMedia = telegramItems)
++        
++        // Then
++        assertEquals(2, streams.telegramMedia.size)
++        assertEquals("tg-1", streams.telegramMedia[0].id)
++        assertEquals("tg-2", streams.telegramMedia[1].id)
++        assertTrue(streams.xtreamLive.isEmpty())
++        assertTrue(streams.xtreamVod.isEmpty())
++        assertTrue(streams.xtreamSeries.isEmpty())
++    }
++
++    @Test
++    fun `HomeContentStreams xtreamLive field contains only live items`() {
++        // Given
++        val liveItems = listOf(
++            createTestItem(id = "live-1", title = "Live Channel 1")
++        )
++        
++        // When
++        val streams = HomeContentStreams(xtreamLive = liveItems)
++        
++        // Then
++        assertEquals(1, streams.xtreamLive.size)
++        assertEquals("live-1", streams.xtreamLive[0].id)
++        assertTrue(streams.telegramMedia.isEmpty())
++        assertTrue(streams.xtreamVod.isEmpty())
++        assertTrue(streams.xtreamSeries.isEmpty())
++    }
++
++    @Test
++    fun `HomeContentStreams xtreamVod field contains only vod items`() {
++        // Given
++        val vodItems = listOf(
++            createTestItem(id = "vod-1", title = "Movie 1"),
++            createTestItem(id = "vod-2", title = "Movie 2"),
++            createTestItem(id = "vod-3", title = "Movie 3")
++        )
++        
++        // When
++        val streams = HomeContentStreams(xtreamVod = vodItems)
++        
++        // Then
++        assertEquals(3, streams.xtreamVod.size)
++        assertEquals("vod-1", streams.xtreamVod[0].id)
++        assertTrue(streams.telegramMedia.isEmpty())
++        assertTrue(streams.xtreamLive.isEmpty())
++        assertTrue(streams.xtreamSeries.isEmpty())
++    }
++
++    @Test
++    fun `HomeContentStreams xtreamSeries field contains only series items`() {
++        // Given
++        val seriesItems = listOf(
++            createTestItem(id = "series-1", title = "TV Show 1")
++        )
++        
++        // When
++        val streams = HomeContentStreams(xtreamSeries = seriesItems)
++        
++        // Then
++        assertEquals(1, streams.xtreamSeries.size)
++        assertEquals("series-1", streams.xtreamSeries[0].id)
++        assertTrue(streams.telegramMedia.isEmpty())
++        assertTrue(streams.xtreamLive.isEmpty())
++        assertTrue(streams.xtreamVod.isEmpty())
++    }
++
++    @Test
++    fun `HomeContentStreams continueWatching and recentlyAdded are independent`() {
++        // Given
++        val continueWatching = listOf(createTestItem(id = "cw-1", title = "Continue 1"))
++        val recentlyAdded = listOf(createTestItem(id = "ra-1", title = "Recent 1"))
++        
++        // When
++        val streams = HomeContentStreams(
++            continueWatching = continueWatching,
++            recentlyAdded = recentlyAdded
++        )
++        
++        // Then
++        assertEquals(1, streams.continueWatching.size)
++        assertEquals("cw-1", streams.continueWatching[0].id)
++        assertEquals(1, streams.recentlyAdded.size)
++        assertEquals("ra-1", streams.recentlyAdded[0].id)
++    }
++
++    // ==================== hasContent Logic Tests ====================
++
++    @Test
++    fun `hasContent is false when all streams are empty`() {
++        // Given
++        val streams = HomeContentStreams()
++        
++        // Then
++        assertFalse(streams.hasContent)
++    }
++
++    @Test
++    fun `hasContent is true when only telegramMedia has items`() {
++        // Given
++        val streams = HomeContentStreams(
++            telegramMedia = listOf(createTestItem(id = "tg-1", title = "Test"))
++        )
++        
++        // Then
++        assertTrue(streams.hasContent)
++    }
++
++    @Test
++    fun `hasContent is true when only xtreamLive has items`() {
++        // Given
++        val streams = HomeContentStreams(
++            xtreamLive = listOf(createTestItem(id = "live-1", title = "Test"))
++        )
++        
++        // Then
++        assertTrue(streams.hasContent)
++    }
++
++    @Test
++    fun `hasContent is true when only xtreamVod has items`() {
++        // Given
++        val streams = HomeContentStreams(
++            xtreamVod = listOf(createTestItem(id = "vod-1", title = "Test"))
++        )
++        
++        // Then
++        assertTrue(streams.hasContent)
++    }
++
++    @Test
++    fun `hasContent is true when only xtreamSeries has items`() {
++        // Given
++        val streams = HomeContentStreams(
++            xtreamSeries = listOf(createTestItem(id = "series-1", title = "Test"))
++        )
++        
++        // Then
++        assertTrue(streams.hasContent)
++    }
++
++    @Test
++    fun `hasContent is true when only continueWatching has items`() {
++        // Given
++        val streams = HomeContentStreams(
++            continueWatching = listOf(createTestItem(id = "cw-1", title = "Test"))
++        )
++        
++        // Then
++        assertTrue(streams.hasContent)
++    }
++
++    @Test
++    fun `hasContent is true when only recentlyAdded has items`() {
++        // Given
++        val streams = HomeContentStreams(
++            recentlyAdded = listOf(createTestItem(id = "ra-1", title = "Test"))
++        )
++        
++        // Then
++        assertTrue(streams.hasContent)
++    }
++
++    @Test
++    fun `hasContent is true when multiple streams have items`() {
++        // Given
++        val streams = HomeContentStreams(
++            telegramMedia = listOf(createTestItem(id = "tg-1", title = "Telegram")),
++            xtreamVod = listOf(createTestItem(id = "vod-1", title = "VOD")),
++            xtreamLive = listOf(createTestItem(id = "live-1", title = "Live"))
++        )
++        
++        // Then
++        assertTrue(streams.hasContent)
++    }
++
++    // ==================== HomeState Consistency Tests ====================
++
++    @Test
++    fun `HomeState hasContent matches HomeContentStreams behavior`() {
++        // Given - empty state
++        val emptyState = HomeState()
++        assertFalse(emptyState.hasContent)
++
++        // Given - state with telegram items
++        val stateWithTelegram = HomeState(
++            telegramMediaItems = listOf(createTestItem(id = "tg-1", title = "Test"))
++        )
++        assertTrue(stateWithTelegram.hasContent)
++
++        // Given - state with mixed items
++        val mixedState = HomeState(
++            xtreamVodItems = listOf(createTestItem(id = "vod-1", title = "Movie")),
++            xtreamSeriesItems = listOf(createTestItem(id = "series-1", title = "Show"))
++        )
++        assertTrue(mixedState.hasContent)
++    }
++
++    @Test
++    fun `HomeState all content fields are independent`() {
++        // Given
++        val state = HomeState(
++            continueWatchingItems = listOf(createTestItem(id = "cw", title = "Continue")),
++            recentlyAddedItems = listOf(createTestItem(id = "ra", title = "Recent")),
++            telegramMediaItems = listOf(createTestItem(id = "tg", title = "Telegram")),
++            xtreamLiveItems = listOf(createTestItem(id = "live", title = "Live")),
++            xtreamVodItems = listOf(createTestItem(id = "vod", title = "VOD")),
++            xtreamSeriesItems = listOf(createTestItem(id = "series", title = "Series"))
++        )
++        
++        // Then - each field contains exactly its item
++        assertEquals(1, state.continueWatchingItems.size)
++        assertEquals("cw", state.continueWatchingItems[0].id)
++        
++        assertEquals(1, state.recentlyAddedItems.size)
++        assertEquals("ra", state.recentlyAddedItems[0].id)
++        
++        assertEquals(1, state.telegramMediaItems.size)
++        assertEquals("tg", state.telegramMediaItems[0].id)
++        
++        assertEquals(1, state.xtreamLiveItems.size)
++        assertEquals("live", state.xtreamLiveItems[0].id)
++        
++        assertEquals(1, state.xtreamVodItems.size)
++        assertEquals("vod", state.xtreamVodItems[0].id)
++        
++        assertEquals(1, state.xtreamSeriesItems.size)
++        assertEquals("series", state.xtreamSeriesItems[0].id)
++    }
++
++    // ==================== Test Helpers ====================
++
++    private fun createTestItem(
++        id: String,
++        title: String,
++        mediaType: MediaType = MediaType.MOVIE,
++        sourceType: SourceType = SourceType.TELEGRAM
++    ): HomeMediaItem = HomeMediaItem(
++        id = id,
++        title = title,
++        mediaType = mediaType,
++        sourceType = sourceType,
++        navigationId = id,
++        navigationSource = sourceType
++    )
++}
diff --git a/infra/cache/build.gradle.kts b/infra/cache/build.gradle.kts
new file mode 100644
index 00000000..d336fb86
--- /dev/null
+++ b/infra/cache/build.gradle.kts
@@ -0,0 +1,44 @@
+plugins {
+    id("com.android.library")
+    id("org.jetbrains.kotlin.android")
+    id("com.google.devtools.ksp")
+    id("com.google.dagger.hilt.android")
+}
+
+android {
+    namespace = "com.fishit.player.infra.cache"
+    compileSdk = 35
+
+    defaultConfig {
+        minSdk = 24
+    }
+
+    compileOptions {
+        sourceCompatibility = JavaVersion.VERSION_17
+        targetCompatibility = JavaVersion.VERSION_17
+    }
+
+    kotlinOptions {
+        jvmTarget = "17"
+    }
+}
+
+dependencies {
+    // Logging (via UnifiedLog facade only - no direct Timber)
+    implementation(project(":infra:logging"))
+    
+    // Coil for image cache access
+    implementation("io.coil-kt.coil3:coil:3.0.4")
+    
+    // Coroutines
+    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.9.0")
+    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.9.0")
+    
+    // Hilt DI
+    implementation("com.google.dagger:hilt-android:2.56.1")
+    ksp("com.google.dagger:hilt-compiler:2.56.1")
+    
+    // Testing
+    testImplementation("junit:junit:4.13.2")
+    testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:1.9.0")
+}
diff --git a/infra/cache/src/main/AndroidManifest.xml b/infra/cache/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..72fe0259
--- /dev/null
+++ b/infra/cache/src/main/AndroidManifest.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android">
+    <!-- No permissions needed - uses app-internal storage only -->
+</manifest>
diff --git a/infra/cache/src/main/java/com/fishit/player/infra/cache/CacheManager.kt b/infra/cache/src/main/java/com/fishit/player/infra/cache/CacheManager.kt
new file mode 100644
index 00000000..96e7c2c2
--- /dev/null
+++ b/infra/cache/src/main/java/com/fishit/player/infra/cache/CacheManager.kt
@@ -0,0 +1,67 @@
+package com.fishit.player.infra.cache
+
+/**
+ * Centralized cache management interface.
+ *
+ * **Contract:**
+ * - All cache size calculations run on IO dispatcher (no main-thread IO)
+ * - All cache clearing operations run on IO dispatcher
+ * - All operations log via UnifiedLog (no secrets in log messages)
+ * - This is the ONLY place where file-system cache operations should occur
+ *
+ * **Architecture:**
+ * - Interface defined in infra/cache
+ * - Implementation (DefaultCacheManager) also in infra/cache
+ * - Consumers (DebugInfoProvider, Settings) inject via Hilt
+ *
+ * **Thread Safety:**
+ * - All methods are suspend functions that internally use Dispatchers.IO
+ * - Callers may invoke from any dispatcher
+ */
+interface CacheManager {
+
+    /**
+     * Get the size of Telegram/TDLib cache in bytes.
+     *
+     * Includes:
+     * - TDLib database directory (tdlib/)
+     * - TDLib files directory (tdlib-files/)
+     *
+     * @return Size in bytes, or 0 if unable to calculate
+     */
+    suspend fun getTelegramCacheSizeBytes(): Long
+
+    /**
+     * Get the size of the image cache (Coil) in bytes.
+     *
+     * Includes:
+     * - Disk cache size
+     *
+     * @return Size in bytes, or 0 if unable to calculate
+     */
+    suspend fun getImageCacheSizeBytes(): Long
+
+    /**
+     * Get the size of the database (ObjectBox) in bytes.
+     *
+     * @return Size in bytes, or 0 if unable to calculate
+     */
+    suspend fun getDatabaseSizeBytes(): Long
+
+    /**
+     * Clear the Telegram/TDLib file cache.
+     *
+     * **Note:** This clears ONLY the files cache (downloaded media),
+     * NOT the database. This preserves chat history while reclaiming space.
+     *
+     * @return true if successful, false on error
+     */
+    suspend fun clearTelegramCache(): Boolean
+
+    /**
+     * Clear the image cache (Coil disk + memory).
+     *
+     * @return true if successful, false on error
+     */
+    suspend fun clearImageCache(): Boolean
+}
diff --git a/infra/cache/src/main/java/com/fishit/player/infra/cache/DefaultCacheManager.kt b/infra/cache/src/main/java/com/fishit/player/infra/cache/DefaultCacheManager.kt
new file mode 100644
index 00000000..f5dd181c
--- /dev/null
+++ b/infra/cache/src/main/java/com/fishit/player/infra/cache/DefaultCacheManager.kt
@@ -0,0 +1,166 @@
+package com.fishit.player.infra.cache
+
+import android.content.Context
+import coil3.ImageLoader
+import com.fishit.player.infra.logging.UnifiedLog
+import dagger.hilt.android.qualifiers.ApplicationContext
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.withContext
+import java.io.File
+import javax.inject.Inject
+import javax.inject.Singleton
+
+/**
+ * Default implementation of [CacheManager].
+ *
+ * **Thread Safety:**
+ * - All file operations run on Dispatchers.IO
+ * - No main-thread blocking
+ *
+ * **Logging:**
+ * - All operations log via UnifiedLog
+ * - No sensitive information in log messages
+ *
+ * **Architecture:**
+ * - This is the ONLY place with direct file system access for caches
+ * - DebugInfoProvider and Settings delegate to this class
+ */
+@Singleton
+class DefaultCacheManager @Inject constructor(
+    @ApplicationContext private val context: Context,
+    private val imageLoader: ImageLoader
+) : CacheManager {
+
+    companion object {
+        private const val TAG = "CacheManager"
+        
+        // TDLib directory names (relative to noBackupFilesDir)
+        private const val TDLIB_DB_DIR = "tdlib"
+        private const val TDLIB_FILES_DIR = "tdlib-files"
+        
+        // ObjectBox directory name (relative to filesDir)
+        private const val OBJECTBOX_DIR = "objectbox"
+    }
+
+    // =========================================================================
+    // Size Calculations
+    // =========================================================================
+
+    override suspend fun getTelegramCacheSizeBytes(): Long = withContext(Dispatchers.IO) {
+        try {
+            val tdlibDir = File(context.noBackupFilesDir, TDLIB_DB_DIR)
+            val filesDir = File(context.noBackupFilesDir, TDLIB_FILES_DIR)
+            
+            var totalSize = 0L
+            
+            if (tdlibDir.exists()) {
+                totalSize += calculateDirectorySize(tdlibDir)
+            }
+            if (filesDir.exists()) {
+                totalSize += calculateDirectorySize(filesDir)
+            }
+            
+            UnifiedLog.d(TAG) { "TDLib cache size: $totalSize bytes" }
+            totalSize
+        } catch (e: Exception) {
+            UnifiedLog.e(TAG, e) { "Failed to calculate TDLib cache size" }
+            0L
+        }
+    }
+
+    override suspend fun getImageCacheSizeBytes(): Long = withContext(Dispatchers.IO) {
+        try {
+            val diskCache = imageLoader.diskCache
+            val size = diskCache?.size ?: 0L
+            
+            UnifiedLog.d(TAG) { "Image cache size: $size bytes" }
+            size
+        } catch (e: Exception) {
+            UnifiedLog.e(TAG, e) { "Failed to calculate image cache size" }
+            0L
+        }
+    }
+
+    override suspend fun getDatabaseSizeBytes(): Long = withContext(Dispatchers.IO) {
+        try {
+            val objectboxDir = File(context.filesDir, OBJECTBOX_DIR)
+            val size = if (objectboxDir.exists()) {
+                calculateDirectorySize(objectboxDir)
+            } else {
+                0L
+            }
+            
+            UnifiedLog.d(TAG) { "Database size: $size bytes" }
+            size
+        } catch (e: Exception) {
+            UnifiedLog.e(TAG, e) { "Failed to calculate database size" }
+            0L
+        }
+    }
+
+    // =========================================================================
+    // Cache Clearing
+    // =========================================================================
+
+    override suspend fun clearTelegramCache(): Boolean = withContext(Dispatchers.IO) {
+        try {
+            // Only clear files directory (downloaded media), preserve database
+            val filesDir = File(context.noBackupFilesDir, TDLIB_FILES_DIR)
+            
+            if (filesDir.exists()) {
+                deleteDirectoryContents(filesDir)
+                UnifiedLog.i(TAG) { "Cleared TDLib files cache" }
+            } else {
+                UnifiedLog.d(TAG) { "TDLib files directory does not exist, nothing to clear" }
+            }
+            true
+        } catch (e: Exception) {
+            UnifiedLog.e(TAG, e) { "Failed to clear TDLib cache" }
+            false
+        }
+    }
+
+    override suspend fun clearImageCache(): Boolean = withContext(Dispatchers.IO) {
+        try {
+            // Clear both disk and memory cache
+            imageLoader.diskCache?.clear()
+            imageLoader.memoryCache?.clear()
+            
+            UnifiedLog.i(TAG) { "Cleared image cache (disk + memory)" }
+            true
+        } catch (e: Exception) {
+            UnifiedLog.e(TAG, e) { "Failed to clear image cache" }
+            false
+        }
+    }
+
+    // =========================================================================
+    // Private Helpers
+    // =========================================================================
+
+    /**
+     * Calculate total size of a directory recursively.
+     * Runs on IO dispatcher (caller's responsibility).
+     */
+    private fun calculateDirectorySize(dir: File): Long {
+        if (!dir.exists()) return 0
+        return dir.walkTopDown()
+            .filter { it.isFile }
+            .sumOf { it.length() }
+    }
+
+    /**
+     * Delete all contents of a directory without deleting the directory itself.
+     * Runs on IO dispatcher (caller's responsibility).
+     */
+    private fun deleteDirectoryContents(dir: File) {
+        if (!dir.exists()) return
+        dir.listFiles()?.forEach { file ->
+            if (file.isDirectory) {
+                file.deleteRecursively()
+            } else {
+                file.delete()
+            }
+        }
+    }
+}
diff --git a/infra/cache/src/main/java/com/fishit/player/infra/cache/di/CacheModule.kt b/infra/cache/src/main/java/com/fishit/player/infra/cache/di/CacheModule.kt
new file mode 100644
index 00000000..231bfc27
--- /dev/null
+++ b/infra/cache/src/main/java/com/fishit/player/infra/cache/di/CacheModule.kt
@@ -0,0 +1,21 @@
+package com.fishit.player.infra.cache.di
+
+import com.fishit.player.infra.cache.CacheManager
+import com.fishit.player.infra.cache.DefaultCacheManager
+import dagger.Binds
+import dagger.Module
+import dagger.hilt.InstallIn
+import dagger.hilt.components.SingletonComponent
+import javax.inject.Singleton
+
+/**
+ * Hilt module for cache management.
+ */
+@Module
+@InstallIn(SingletonComponent::class)
+abstract class CacheModule {
+
+    @Binds
+    @Singleton
+    abstract fun bindCacheManager(impl: DefaultCacheManager): CacheManager
+}
diff --git a/infra/logging/src/main/java/com/fishit/player/infra/logging/LogBufferTree.kt b/infra/logging/src/main/java/com/fishit/player/infra/logging/LogBufferTree.kt
index 2e0ff9b5..9dee7774 100644
--- a/infra/logging/src/main/java/com/fishit/player/infra/logging/LogBufferTree.kt
+++ b/infra/logging/src/main/java/com/fishit/player/infra/logging/LogBufferTree.kt
@@ -104,12 +104,22 @@ class LogBufferTree(
     fun size(): Int = lock.read { buffer.size }
 
     override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {
+        // MANDATORY: Redact sensitive information before buffering
+        // Contract: No secrets may persist in memory (LOGGING_CONTRACT_V2)
+        val redactedMessage = LogRedactor.redact(message)
+        val redactedThrowable = t?.let { original ->
+            LogRedactor.RedactedThrowable(
+                originalType = original::class.simpleName ?: "Unknown",
+                redactedMessage = LogRedactor.redact(original.message ?: "")
+            )
+        }
+
         val entry = BufferedLogEntry(
             timestamp = System.currentTimeMillis(),
             priority = priority,
             tag = tag,
-            message = message,
-            throwable = t
+            message = redactedMessage,
+            throwable = redactedThrowable
         )
 
         lock.write {
diff --git a/infra/logging/src/main/java/com/fishit/player/infra/logging/LogRedactor.kt b/infra/logging/src/main/java/com/fishit/player/infra/logging/LogRedactor.kt
new file mode 100644
index 00000000..9e56929d
--- /dev/null
+++ b/infra/logging/src/main/java/com/fishit/player/infra/logging/LogRedactor.kt
@@ -0,0 +1,112 @@
+package com.fishit.player.infra.logging
+
+/**
+ * Log redactor for removing sensitive information from log messages.
+ *
+ * **Contract (LOGGING_CONTRACT_V2):**
+ * - All buffered logs MUST be redacted before storage
+ * - Redaction is deterministic and non-reversible
+ * - No secrets (passwords, tokens, API keys) may persist in memory
+ *
+ * **Redaction patterns:**
+ * - `username=...` → `username=***`
+ * - `password=...` → `password=***`
+ * - `Bearer <token>` → `Bearer ***`
+ * - `api_key=...` → `api_key=***`
+ * - Xtream query params: `&user=...`, `&pass=...`
+ *
+ * **Thread Safety:**
+ * - All methods are stateless and thread-safe
+ * - No internal mutable state
+ */
+object LogRedactor {
+
+    // Regex patterns for sensitive data
+    private val PATTERNS: List<Pair<Regex, String>> = listOf(
+        // Standard key=value patterns (case insensitive)
+        Regex("""(?i)(username|user|login)\s*=\s*[^\s&,;]+""") to "$1=***",
+        Regex("""(?i)(password|pass|passwd|pwd)\s*=\s*[^\s&,;]+""") to "$1=***",
+        Regex("""(?i)(api_key|apikey|api-key)\s*=\s*[^\s&,;]+""") to "$1=***",
+        Regex("""(?i)(token|access_token|auth_token)\s*=\s*[^\s&,;]+""") to "$1=***",
+        Regex("""(?i)(secret|client_secret)\s*=\s*[^\s&,;]+""") to "$1=***",
+        
+        // Bearer token pattern
+        Regex("""Bearer\s+[A-Za-z0-9\-._~+/]+=*""") to "Bearer ***",
+        
+        // Basic auth header
+        Regex("""Basic\s+[A-Za-z0-9+/]+=*""") to "Basic ***",
+        
+        // Xtream-specific URL query params
+        Regex("""(?i)[?&](username|user)=[^&\s]+""") to "$1=***",
+        Regex("""(?i)[?&](password|pass)=[^&\s]+""") to "$1=***",
+        
+        // JSON-like patterns
+        Regex(""""(password|pass|passwd|pwd|token|api_key|secret)"\s*:\s*"[^"]*"""") to """"$1":"***"""",
+        
+        // Phone numbers (for Telegram auth)
+        Regex("""(?<!\d)\+?\d{10,15}(?!\d)""") to "***PHONE***"
+    )
+
+    /**
+     * Redact sensitive information from a log message.
+     *
+     * @param message The original log message
+     * @return The redacted message with secrets replaced by ***
+     */
+    fun redact(message: String): String {
+        if (message.isBlank()) return message
+        
+        var result = message
+        for ((pattern, replacement) in PATTERNS) {
+            result = pattern.replace(result, replacement)
+        }
+        return result
+    }
+
+    /**
+     * Redact sensitive information from a throwable's message.
+     *
+     * @param throwable The throwable to redact
+     * @return A redacted version of the throwable message, or null if no message
+     */
+    fun redactThrowable(throwable: Throwable?): String? {
+        val message = throwable?.message ?: return null
+        return redact(message)
+    }
+
+    /**
+     * Create a redacted copy of a [BufferedLogEntry].
+     *
+     * @param entry The original log entry
+     * @return A new entry with redacted message and throwable message
+     */
+    fun redactEntry(entry: BufferedLogEntry): BufferedLogEntry {
+        return entry.copy(
+            message = redact(entry.message),
+            // Create a wrapper throwable with redacted message if original has throwable
+            throwable = entry.throwable?.let { original ->
+                RedactedThrowable(
+                    originalType = original::class.simpleName ?: "Unknown",
+                    redactedMessage = redact(original.message ?: "")
+                )
+            }
+        )
+    }
+
+    /**
+     * Wrapper throwable that stores only the redacted message.
+     *
+     * This ensures no sensitive information from the original throwable
+     * persists in memory through stack traces or cause chains.
+     */
+    class RedactedThrowable(
+        private val originalType: String,
+        private val redactedMessage: String
+    ) : Throwable(redactedMessage) {
+        
+        override fun toString(): String = "[$originalType] $redactedMessage"
+        
+        // Override to prevent exposing stack trace of original exception
+        override fun fillInStackTrace(): Throwable = this
+    }
+}
diff --git a/infra/logging/src/test/java/com/fishit/player/infra/logging/LogRedactorTest.kt b/infra/logging/src/test/java/com/fishit/player/infra/logging/LogRedactorTest.kt
new file mode 100644
index 00000000..1e944865
--- /dev/null
+++ b/infra/logging/src/test/java/com/fishit/player/infra/logging/LogRedactorTest.kt
@@ -0,0 +1,195 @@
+package com.fishit.player.infra.logging
+
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertFalse
+import org.junit.Assert.assertTrue
+import org.junit.Test
+
+/**
+ * Unit tests for [LogRedactor].
+ *
+ * Verifies that all sensitive patterns are properly redacted.
+ */
+class LogRedactorTest {
+
+    // ==================== Username/Password Patterns ====================
+
+    @Test
+    fun `redact replaces username in key=value format`() {
+        val input = "Request with username=john.doe&other=param"
+        val result = LogRedactor.redact(input)
+        
+        assertTrue(result.contains("username=***"))
+        assertFalse(result.contains("john.doe"))
+    }
+
+    @Test
+    fun `redact replaces password in key=value format`() {
+        val input = "Login attempt: password=SuperSecret123!"
+        val result = LogRedactor.redact(input)
+        
+        assertTrue(result.contains("password=***"))
+        assertFalse(result.contains("SuperSecret123"))
+    }
+
+    @Test
+    fun `redact replaces user and pass Xtream params`() {
+        val input = "URL: http://server.com/get.php?user=admin&pass=secret123"
+        val result = LogRedactor.redact(input)
+        
+        assertFalse(result.contains("admin"))
+        assertFalse(result.contains("secret123"))
+    }
+
+    // ==================== Token/API Key Patterns ====================
+
+    @Test
+    fun `redact replaces Bearer token`() {
+        val input = "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.test"
+        val result = LogRedactor.redact(input)
+        
+        assertTrue(result.contains("Bearer ***"))
+        assertFalse(result.contains("eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9"))
+    }
+
+    @Test
+    fun `redact replaces Basic auth`() {
+        val input = "Authorization: Basic YWRtaW46cGFzc3dvcmQ="
+        val result = LogRedactor.redact(input)
+        
+        assertTrue(result.contains("Basic ***"))
+        assertFalse(result.contains("YWRtaW46cGFzc3dvcmQ="))
+    }
+
+    @Test
+    fun `redact replaces api_key parameter`() {
+        val input = "API call with api_key=sk-12345abcde"
+        val result = LogRedactor.redact(input)
+        
+        assertTrue(result.contains("api_key=***"))
+        assertFalse(result.contains("sk-12345abcde"))
+    }
+
+    // ==================== JSON Patterns ====================
+
+    @Test
+    fun `redact replaces password in JSON`() {
+        val input = """{"username": "admin", "password": "secret123"}"""
+        val result = LogRedactor.redact(input)
+        
+        assertTrue(result.contains(""""password":"***""""))
+        assertFalse(result.contains("secret123"))
+    }
+
+    @Test
+    fun `redact replaces token in JSON`() {
+        val input = """{"token": "abc123xyz", "other": "value"}"""
+        val result = LogRedactor.redact(input)
+        
+        assertTrue(result.contains(""""token":"***""""))
+        assertFalse(result.contains("abc123xyz"))
+    }
+
+    // ==================== Phone Number Patterns ====================
+
+    @Test
+    fun `redact replaces phone numbers`() {
+        val input = "Telegram auth for +49123456789"
+        val result = LogRedactor.redact(input)
+        
+        assertTrue(result.contains("***PHONE***"))
+        assertFalse(result.contains("+49123456789"))
+    }
+
+    @Test
+    fun `redact does not affect short numbers`() {
+        val input = "Error code: 12345"
+        val result = LogRedactor.redact(input)
+        
+        // Short numbers should not be redacted (not phone-like)
+        assertTrue(result.contains("12345"))
+    }
+
+    // ==================== Edge Cases ====================
+
+    @Test
+    fun `redact handles empty string`() {
+        assertEquals("", LogRedactor.redact(""))
+    }
+
+    @Test
+    fun `redact handles blank string`() {
+        assertEquals("   ", LogRedactor.redact("   "))
+    }
+
+    @Test
+    fun `redact handles string without secrets`() {
+        val input = "Normal log message without any sensitive data"
+        assertEquals(input, LogRedactor.redact(input))
+    }
+
+    @Test
+    fun `redact handles multiple secrets in one string`() {
+        val input = "user=admin&password=secret&api_key=xyz123"
+        val result = LogRedactor.redact(input)
+        
+        assertFalse(result.contains("admin"))
+        assertFalse(result.contains("secret"))
+        assertFalse(result.contains("xyz123"))
+    }
+
+    // ==================== Case Insensitivity ====================
+
+    @Test
+    fun `redact is case insensitive for keywords`() {
+        val inputs = listOf(
+            "USERNAME=test",
+            "Username=test",
+            "PASSWORD=secret",
+            "Password=secret",
+            "API_KEY=key",
+            "Api_Key=key"
+        )
+        
+        for (input in inputs) {
+            val result = LogRedactor.redact(input)
+            assertFalse("Failed for: $input", result.contains("test") || result.contains("secret") || result.contains("key"))
+        }
+    }
+
+    // ==================== Throwable Redaction ====================
+
+    @Test
+    fun `redactThrowable handles null`() {
+        assertEquals(null, LogRedactor.redactThrowable(null))
+    }
+
+    @Test
+    fun `redactThrowable redacts exception message`() {
+        val exception = IllegalArgumentException("Invalid password=secret123")
+        val result = LogRedactor.redactThrowable(exception)
+        
+        assertFalse(result?.contains("secret123") ?: true)
+    }
+
+    // ==================== BufferedLogEntry Redaction ====================
+
+    @Test
+    fun `redactEntry creates redacted copy`() {
+        val entry = BufferedLogEntry(
+            timestamp = System.currentTimeMillis(),
+            priority = android.util.Log.DEBUG,
+            tag = "Test",
+            message = "Login with password=secret123",
+            throwable = null
+        )
+        
+        val redacted = LogRedactor.redactEntry(entry)
+        
+        assertFalse(redacted.message.contains("secret123"))
+        assertTrue(redacted.message.contains("password=***"))
+        assertEquals(entry.timestamp, redacted.timestamp)
+        assertEquals(entry.priority, redacted.priority)
+        assertEquals(entry.tag, redacted.tag)
+    }
+}
diff --git a/settings.gradle.kts b/settings.gradle.kts
index f04948b3..2778b0b3 100644
--- a/settings.gradle.kts
+++ b/settings.gradle.kts
@@ -84,6 +84,7 @@ include(":feature:onboarding")
 
 // Infrastructure
 include(":infra:logging")
+include(":infra:cache")
 include(":infra:tooling")
 include(":infra:transport-telegram")
 include(":infra:transport-xtream")
