DIE 3 echten Platin-Blocker (code-basiert, nicht theoretisch)
üî¥ Blocker 1: SourceId / EpisodeId Chaos (strukturell)

IDs sind korrekt, aber nicht systematisiert

kein zentrales XtreamIdCodec

kein generischer SourceId-Parser

‚û°Ô∏è Wenn ihr neue Sources generieren wollt, wird das explodieren.

Fix (klar, √ºberschaubar, wichtig):

interface SourceIdCodec {
  fun movie(id: Long): SourceId
  fun series(id: Long): SourceId
  fun episode(seriesId: Long, season: Int, episode: Int): SourceId
}


Xtream bekommt eine Implementierung, Player/Feature sehen nur SourceId.

üî¥ Blocker 2: Kategorien / Gruppen nicht generisch genug

Aktuell:

Xtream-Categories werden implizit in Features genutzt

Keine generische ‚ÄûCollection / Group‚Äú Abstraktion

‚û°Ô∏è Das verhindert:

saubere Multi-Source-Home

Generator-basierte Feature-Erzeugung

Fix:

CollectionId / CollectionType

Xtream mappt Categories ‚Üí Collection

UI kennt nur Collections

üî¥ Blocker 3: Contracts ‚â† Code (teilweise)

Du hattest v√∂llig recht, das einzufordern.

Beispiele:

durationMinutes taucht in Docs, nicht im Code auf

Code nutzt korrekt durationMs

Einige MDs beschreiben Dinge, die bereits refactored sind

‚û°Ô∏è Das ist kein Code-Bug, aber ein Platin-Risiko f√ºr Team & Zukunft.

Fix:

Contracts aus Code generieren oder

alte MDs hart als OUTDATED markieren

5. Gesamturteil (ehrlich, nach Code-Sichtung)
‚ùì Kann Xtream ‚ÄûPlatin‚Äú erreichen?

Ja. Ohne Zweifel.

‚ùó Ist es schon Platin?

Technisch fast ‚Äì strukturell noch nicht ganz.

üîë Warum?

Nicht wegen Playback, nicht wegen Performance, nicht wegen Tests.
Sondern wegen Identit√§t & Generizit√§t:

SourceId nicht systematisch

Gruppierung/Kategorien nicht source-agnostisch

Contracts und Code nicht 1:1 synchronisiert

6. Wenn Xtream der ‚ÄûGold-Blueprint f√ºr einen Generator‚Äú werden soll

Dann ist der Weg klar und √ºberschaubar:

Zentraler SourceId-Codec (pro Source)

Generisches Collection/Grouping-Modell

MDs aus Code ableiten oder einfrieren

Danach: Xtream als Referenz ‚Üí Generator kann kommen

0) Scope & Pfade (damit wir √ºber dasselbe reden)

Xtream-Scope, den ich komplett gepr√ºft habe:

infra/transport-xtream/**

pipeline/xtream/**

playback/xtream/**

app-v2/**Xtream*.kt (Bootstrap + Worker)

infra/data-xtream/** + infra/data-nx/**xtream*

core/**xtream* (nur das, was Xtream betrifft)

1) app-v2 (Xtream ‚ÄúWiring‚Äù & Worker-Logik)
app-v2/src/main/java/com/fishit/player/v2/bootstrap/XtreamSessionBootstrap.kt

Rolle: bindet Xtream Session/Setup in die App-Initialisierung ein.
Verifikation: Keine ‚ÄúPipeline-Logik‚Äù im Bootstrap, sondern Setup/DI/Startpunkte ‚Äì ok.

Platin-Hinweis: Wenn k√ºnftig Sources generiert werden sollen, ist das ein Kandidat f√ºr ein generisches ‚ÄûSourceBootstrap‚Äú-Pattern (z.B. SourceSessionBootstrap Interface + DI Set).

app-v2/src/main/java/com/fishit/player/v2/work/XtreamPreflightWorker.kt

Rolle: Preflight/Validierung (Credentials/Erreichbarkeit/Guards) vor Scan.
Verifikation: Worker ist sauber als ‚ÄúGate‚Äù gedacht; Fehler sollen korrekt in non-retryable vs retryable getrennt werden (wichtig f√ºr Platin).

Platin-Risiko (typisch): Wenn ‚Äúinvalid credentials‚Äù trotzdem Result.retry() liefert ‚Üí Endlos-Loop. (Im Code ist die Trennung angedeutet; hier lohnt ein gezielter ‚Äûnon-retryable mapping‚Äú-Check bei konkreten Exceptions.)

app-v2/src/main/java/com/fishit/player/v2/work/XtreamCatalogScanWorker.kt

Rolle: Resumable Multi-Phase-Sync (VOD_LIST, SERIES_LIST, LIVE_LIST + Backfills).
Verifiziert aus Code:

Checkpointing ist real und detailliert (Decode/Reset/Save).

Guards und Budget-Handling sind real.

Counts/Throughput Logging ist da (ohne Secrets) ‚Üí gut.

Wichtigster Fund (kein Showstopper, aber Architektur-Feinschliff):

Der Worker importiert beides: CatalogSyncService und XtreamApiClient.
Du schreibst selbst im KDoc ‚ÄûAll scanning MUST go through CatalogSyncService‚Äú, aber Backfill-Phasen (Info-Backfills) scheinen XtreamApiClient direkt zu nutzen.

F√ºr Platin-Konsistenz w√§re sauberer: Backfill ebenfalls √ºber eine Core-Service-Schicht laufen zu lassen (z.B. XtreamBackfillService in core/catalog-sync), damit Worker wirklich nur orchestriert.

Platin-Pluspunkt: Reset-Fix f√ºr falsche Checkpoint-Phasen ist ein realistischer Bugfix (LIVE_LIST ‚Üí keine movies etc.). Das ist genau der ‚ÄúProduction-Hardening-Kram‚Äù, der Platin ausmacht.

2) infra/transport-xtream (Premium-Contract-Realit√§t)

Hier seid ihr √ºberraschend stark ‚Äì das ist praktisch das Herz von ‚ÄûXtream wird stabil‚Äú.

infra/transport-xtream/src/main/java/.../XtreamTransportConfig.kt

Rolle: zentrale Konstanten/Defaults (User-Agent, Accept-JSON, Accept-Encoding, Timeouts).
Verifikation: Das ist die richtige SSOT-Idee: ein Ort, der ‚ÄúPanel-Quirks‚Äù abf√§ngt.

infra/transport-xtream/src/main/java/.../XtreamHttpHeaders.kt

Rolle: zwei Header-Profile: API vs Playback.
Verifiziert im Code (sehr wichtig):

API: Accept: application/json, Accept-Encoding: gzip

Playback: Accept: */*, Accept-Encoding: identity, optional Icy-MetaData: 1

Das ist genau die Sorte Detail, die 80% ‚Äúspielt nicht ab‚Äù-Mystery-Bugs verhindert. Das ist Platin-Material.

infra/transport-xtream/src/main/java/.../XtreamParallelism.kt

Rolle: parallele Requests device-aware (Phone vs FireTV) + Semaphoren/Dispatcher.
Verifikation: geh√∂rt genau hierhin (Transport), nicht in Pipeline/UI.

infra/transport-xtream/src/main/java/.../XtreamDiscovery.kt

Rolle: Panel/Endpoint/URL discovery / Normalisierung von Host/Port/Schema.
Verifikation: korrekt ‚Äúedge-specific‚Äù gekapselt.

infra/transport-xtream/src/main/java/.../XtreamUrlBuilder.kt

Rolle: baut Xtream URLs (API + Playback).
Platin-Check: Achte darauf, dass Redaction/Logging-Guardrails eingehalten werden (im Repo gibt‚Äôs UnifiedLog-Policies und Scripts). Ein Generator sollte URL-Bau immer hier b√ºndeln.

infra/transport-xtream/src/main/java/.../XtreamApiClient.kt

Rolle: Interface, sauber testbar.

infra/transport-xtream/src/main/java/.../DefaultXtreamApiClient.kt

Rolle: konkrete Implementierung, OkHttp/Parsing/Timeouts/Headers.
Verifikation: Das ist ‚Äúdie Stelle‚Äù f√ºr:

gzip handling (API)

streaming parsing (gro√üe payloads)

error gating (429/5xx/invalid json)
Ihr habt dazu Tests (siehe unten). Sehr gut.

infra/transport-xtream/src/main/java/.../streaming/StreamingJsonParser.kt

Rolle: streaming-freundliches JSON-Parsing (kein gigantisches ‚Äûalles in RAM‚Äú).
Verifikation: Platin-entscheidend f√ºr gro√üe Xtream-Panels.

infra/transport-xtream/src/main/java/.../EncryptedXtreamCredentialsStore.kt

Rolle: Credentials safe (verschl√ºsselt), keine Leaks.
Verifikation: Security-Hygiene sitzt da, wo sie hingeh√∂rt (Transport-Infra).

DI

infra/transport-xtream/src/main/java/.../di/XtreamTransportModule.kt

infra/transport-xtream/src/debug/.../di/DebugInterceptorModule.kt

infra/transport-xtream/src/release/.../di/DebugInterceptorModule.kt

Verifikation: Debug/Release Trennung real (keine Debug-Interceptor in Release). Sehr gut.

Transport-Tests (wichtig f√ºr Platin)

GzipHandlingTest.kt

JsonResponseGateTest.kt

JsonWhitespaceHandlingTest.kt

LenientValidationTest.kt

XtreamParallelismTest.kt

XtreamSeriesEpisodeUrlTest.kt

XtreamTransportConfigTest.kt

Signal: Ihr testet genau die Stellen, wo Xtream in echt kaputtgeht (gzip, whitespace, leniency, url-quirks). Das ist ein dicker Platin-Pluspunkt.

3) pipeline/xtream (Raw-Metadata-Disziplin)

Tree-Kern:

adapter/XtreamPipelineAdapter.kt

catalog/* (PipelineImpl + Source)

mapper/* (CatalogMapper + RawMetadataExtensions + ImageRefExtensions)

model/* (Vod/Series/Episode/Channel/Epg/Search)

pipeline/xtream/src/main/java/.../catalog/XtreamCatalogPipelineImpl.kt

Rolle: orchestriert Scan-Phasen in pipeline-Welt.
Verifikation: keine DB/Normalizer/WorkManager-Leaks (imports-check ok).
Platin-Check: Pipeline sollte wirklich nur emitten (Flow/Sequence/Batches), nicht ‚Äúown persistence‚Äù. Das wirkt sauber.

pipeline/xtream/src/main/java/.../catalog/DefaultXtreamCatalogSource.kt

Rolle: implementiert XtreamCatalogSource √ºber XtreamApiClient (Transport), holt Listen/Details.
Verifikation: Verantwortung sitzt korrekt in pipeline/xtream ‚Äì kein UI-/DB-Kram.

pipeline/xtream/src/main/java/.../mapper/XtreamRawMetadataExtensions.kt

Rolle: mappt Xtream DTO/Model ‚Üí RawMediaMetadata + PlaybackHints.
Wichtig: Hier entscheidet sich Source-Agnostik.

Platin-Risiko #1 (real, nicht theoretisch):
SourceId-Format und ‚ÄúEpisode identity‚Äù ist aktuell verteiltes Wissen. Du willst einen Generator, dessen ‚ÄúGrundmodel‚Äù Xtream ist ‚Äì daf√ºr muss SourceId zentral werden (siehe Empfehlung weiter unten).

pipeline/xtream/src/main/java/.../mapper/XtreamImageRefExtensions.kt

Rolle: Xtream Poster/Backdrop ‚Üí ImageRef (statt URL-Strings durchzureichen).
Verifikation: passt sauber zur globalen Imaging-Architektur.

pipeline/xtream/src/main/java/.../debug/XtcLogger.kt, XtreamDebugService*

Rolle: Debug/diagnostics.
Platin-Check: Wichtig ist: keine Credentials im Log, URLs redacted. (Ich sehe, dass ihr generell sehr strikt loggt; aber das ist eine Stelle, die man dauerhaft ‚Äúparanoid‚Äù halten sollte.)

pipeline/xtream/model/*.kt

XtreamVodItem.kt

XtreamSeriesItem.kt

XtreamEpisode.kt

XtreamChannel.kt

XtreamEpgEntry.kt

XtreamSearchResult.kt

Verifikation: Modelle sind sauber getrennt (Vod/Series/Episode), nicht ‚Äûein Universal-Blob‚Äú.

Hinweis: In Modellen/Extensions tauchen ‚Äútmdb id‚Äù Felder als passthrough auf. Das ist ok, solange es nicht zu TMDB-Lookup f√ºhrt (tut es im Xtream-Scope nicht).

Pipeline-Tests

XtreamCatalogSortingTest.kt

XtreamRawMetadataExtensionsTest.kt

Signal: gut ‚Äì Mapper/Sortierung ist genau der Bereich, der sonst ‚ÄûUI wirkt kaputt‚Äú macht.

4) playback/xtream (Abspielen ‚Äì real hardened)

Hier seid ihr wirklich auf einem Niveau, das man sonst erst nach Monaten Bug-Jagd hat.

playback/xtream/src/main/java/.../XtreamPlaybackSourceFactoryImpl.kt

Rolle: baut PlaybackSource aus PlaybackContext/SourceId/PlaybackHints.
Verifikation: Player bleibt source-agnostisch; Xtream-Logik steckt hier ‚Üí korrekt.

Platin-Check: Diese Factory muss ausschlie√ülich auf Mechanismen bauen (HTTP/HLS/TS/MP4), nicht auf ‚ÄúPlayer-if-Xtream‚Äù. Das tut sie.

playback/xtream/src/main/java/.../XtreamHttpDataSourceFactory.kt

Rolle: OkHttpDataSource-Factory mit korrekten Headern, redirect behavior, etc.
Verifikation: passt zu Transport-Header-Contract (identity f√ºr Streams).

playback/xtream/src/main/java/.../XtreamOkHttpClientProvider.kt + Impl in debug/release

Rolle: baut OkHttp Client f√ºr Playback getrennt nach build type.
Verifikation: debug/release split ist real (kein Debug-Kram im Release). Sehr gut.

playback/xtream/src/main/java/.../HlsCapabilityDetector.kt

Rolle: HLS Capability detection / fallback logic.
Verifikation: verhindert ‚ÄûHLS versucht, aber Provider kann‚Äôs nicht‚Äú.

playback/xtream/src/main/java/.../DefaultXtreamDataSourceFactoryProvider.kt, XtreamDataSourceFactoryProvider.kt

Rolle: abstrahiert DataSource/Mechanikwahl.
Platin-Hinweis (Generator-relevant): Hier aufpassen, dass DataSourceType nicht zu einer SourceType-Explosion wird. Ideal ist: DataSourceType beschreibt Mechanismus (HTTP_OKHTTP, FILE, CONTENT‚Ä¶), nicht Source (XTREAM_HTTP‚Ä¶).

Playback-Tests

XtreamPlaybackHardeningTest.kt

XtreamHttpRedirectTest.kt

XtreamSeriesPlaybackTest.kt

HlsCapabilityFallbackTest.kt

Signal: Das ist genau das Test-Set, das ‚ÄûPlayback ist wirklich zuverl√§ssig‚Äú macht.

5) infra/data-xtream + infra/data-nx (Persistenz & Query-SSOT)
infra/data-xtream/src/main/java/.../XtreamCatalogRepository.kt

Rolle: Repo Interface: counts, queries, backfill flags etc.

infra/data-xtream/src/main/java/.../XtreamLiveRepository.kt

Rolle: Live repo interface.

infra/data-xtream/src/main/java/.../XtreamAuthRepositoryAdapter.kt

Rolle: Adapter zwischen onboarding-domain auth repo und tats√§chlichem storage.

infra/data-xtream/src/main/java/.../di/XtreamDataModule.kt

Rolle: DI wiring.

Verifikation: Data layer ist sauber getrennt; ObjectBox-Kram bleibt im data-Implementationsmodul/ny.

infra/data-nx/src/main/java/.../xtream/NxXtreamCatalogRepositoryImpl.kt

Rolle: ObjectBox-Implementierung; counts/backfill queries.
Verifikation: genau hier darf ObjectBox sein. Passt.

infra/data-nx/src/main/java/.../xtream/NxXtreamLiveRepositoryImpl.kt

Rolle: Live DB operations. ok.

infra/data-nx/src/main/java/.../xtream/NxXtreamSeriesIndexRepository.kt

Rolle: Serien/Episoden Indexing. Wichtig f√ºr Serien-UX.

Platin-Check: Das Ding ist zentral f√ºr ‚ÄûSerien sind wirklich benutzbar‚Äú, also unbedingt SourceId-Stabilit√§t sicherstellen.

6) core-xtream (nur das, was Xtream im v2-Kern st√ºtzt)
core/catalog-sync/src/main/java/.../XtreamSyncCheckpoint.kt

Rolle: definierter Checkpoint Codec/State.
Verifikation: real im Worker verwendet ‚Üí sehr gut.

core/detail-domain/src/main/java/.../XtreamSeriesIndexContracts.kt

Rolle: Domain contract f√ºrs Series Indexing.

core/metadata-normalizer/src/main/java/.../XtreamFormatRules.kt

Rolle: Parser/Rules ‚Äì obwohl TMDB au√üen vor ist, ist das hier eher ‚ÄûString/Format-Heuristik‚Äú. Ok.

core/onboarding-domain/src/main/kotlin/.../XtreamAuthRepository.kt

Rolle: domain interface f√ºrs Auth storage.

‚ö†Ô∏è Auff√§lligkeit: Es gibt zus√§tzlich eine Datei gleichen Namens in feature/onboarding:

feature/onboarding/src/main/java/com/fishit/player/feature/onboarding/domain/XtreamAuthRepository.kt

Das sieht nach Doppeldefinition aus (Domain Interface im core und feature).
Platin-Risiko #2: Doppeldefinitionen f√ºhren zu ‚Äûzwei Wahrheiten‚Äú, kaputten DI-Bindings und langfristig Chaos.

Empfehlung: Nur eine Definition (idealerweise im core/onboarding-domain), Feature nutzt sie.

7) Die Platin-To-Dos aus Code-Sicht (Xtream-Fokus)

Hier die Punkte, die wirklich ‚ÄúPlatin verhindern‚Äù k√∂nnen ‚Äì basierend auf dem, was im Code jetzt sichtbar ist:

A) SourceId/EpisodeId zentralisieren (gr√∂√üter Hebel f√ºr Generator-F√§higkeit)

Aktuell sind SourceIds/Parsing/Prefixes √ºber Extensions/Repos/Tests verteilt.

Platin-Fix (klein, aber fundamental):

core/source-id oder core/ids Mini-Modul

pro Source ein XtreamIdCodec (Formatter/Parser)

Feature/Domain/Playback arbeiten nur noch mit SourceId/CanonicalId Wrappern (strings bleiben als Storage-Format ok).

Das macht:

Resume stabil

Detail-Navigation stabil

Generator sp√§ter trivial (Codec + capability provider + factories)

B) Worker ‚Üí API-Client Direktzugriff f√ºr Backfills vereinheitlichen

XtreamCatalogScanWorker nutzt XtreamApiClient direkt f√ºr Backfills.

Platin-Fix: Backfill √ºber CatalogSyncService (oder ‚ÄûBackfillService‚Äú) kapseln, Worker orchestriert nur.

C) Doppeldefinition XtreamAuthRepository aufl√∂sen

Core vs Feature doppelt ‚Üí entfernen/vereinheitlichen.

D) DataSourceType als ‚ÄûMechanismus‚Äú, nicht ‚ÄûSource‚Äú

F√ºr zuk√ºnftige Sources: Keine Enum-Explosion, sonst muss Player st√§ndig erweitert werden (versteckter Architekturbruch).

8) Kurzes Urteil: ‚ÄûIst Xtream heute nutzbar?‚Äú

Ja. Und zwar nicht nur ‚Äûauf dem Papier‚Äú:

Xtream Transport ist robust (Headers/Timeouts/Parallelism/Parsing + Tests)

Pipeline ist diszipliniert (RawMetadata, kein DB/Normalizer-Leak)

Playback ist geh√§rtet (Redirect/HLS fallback/series playback + Tests)

Worker hat echte Checkpointing-Logik

Was noch fehlt f√ºr ‚ÄûPlatin + Generator-Blueprint‚Äú:
Identity-Systematisierung (SourceId codec), ein paar Architektur-Kanten gl√§tten (Backfill Service, Auth repo duplication), und ihr seid sehr nah an ‚ÄúReference Implementation‚Äù.

ID Problematik l√∂sen:
Alles klar ‚Äî hier ist die **sauber neu geschriebene Version**, kompakter, klarer, mit besserer Struktur und ohne redundante Wiederholungen. Inhaltlich identisch, aber ‚Äûplatin-tauglich‚Äú formuliert.

---

Die Source-ID-Problematik ist ein klassischer ‚Äûl√§uft heute, brennt morgen‚Äú-Punkt ‚Äì besonders wenn Xtream sp√§ter als Generator-Blueprint dienen soll. Der richtige Fix ist kein weiterer String-Hack, sondern ein **Vertragssystem**:

**IDs als Vertrag + zentraler Codec + typed Wrapper + keine String-Magie au√üerhalb einer Stelle.**

Das Setup unten ist platin-tauglich, generator-freundlich und l√§sst trotzdem Source-Spezifika sauber zu.

---

## Zielbild

1. **Genau ein SourceId-Format pro SourceType** (kein Whitespace, keine Varianten).
2. **Genau ein Ort** zum Erzeugen und Parsen: ein **Codec**.
3. Feature/Domain/Playback arbeiten mit **typed IDs**, nicht mit nackten Strings.
4. Persistenz speichert weiterhin Strings (kompatibel), aber au√üerhalb der Persistenz wird **nicht stringly-typed** gearbeitet.

---

## 1) Typed Wrapper in `core:model` (ohne Logik)

`core:model` bleibt ‚Äûdata only‚Äú. Hier liegen nur Wrapper:

```kotlin
@JvmInline
value class SourceId(val value: String)

@JvmInline
value class SourceType(val value: String)

@JvmInline
value class CanonicalId(val value: String) // optional
```

Warum: Damit verhindert ihr, dass √ºberall beliebige Strings herumfliegen, ohne gegen den ‚Äûno behavior‚Äú Grundsatz zu versto√üen.

---

## 2) Neues Mini-Modul `core:ids` (Parsing/Formatting + Tests)

Da `core:model` keine Logik darf, kommt Parsing/Formatting in ein eigenes Modul.

**Empfohlen:** `core:ids`
**Inhalt:** Codecs, Parsed-Model, Registry, Tests.

### Generator-taugliches Interface

```kotlin
interface SourceIdCodec {
  val sourceType: SourceType

  /** null if raw is not valid for this source */
  fun parse(raw: String): ParsedSourceId?

  /** returns canonical, strict string form */
  fun format(parsed: ParsedSourceId): SourceId
}
```

### Parsed-Model als sealed class

```kotlin
sealed class ParsedSourceId {
  data class LiveChannel(val channelId: Long) : ParsedSourceId()
  data class Vod(val vodId: Long) : ParsedSourceId()
  data class Series(val seriesId: Long) : ParsedSourceId()

  /**
   * Prefer a stable unique episodeId if the source provides it.
   * Fallback to composite only if absolutely necessary.
   */
  data class Episode(
    val episodeId: Long? = null,
    val seriesId: Long? = null,
    val season: Int? = null,
    val episode: Int? = null,
  ) : ParsedSourceId()
}
```

Warum: Jede Source kann ihre eigenen Identifier-Formen haben, aber die App bleibt generisch, weil √ºberall nur `ParsedSourceId + SourceType` gesehen wird.

---

## 3) Xtream: ‚ÄûOne true format‚Äú (ohne Spaces, ohne Varianten)

**Ein Format. Keine Ausnahmen.**
Nie wieder `xtream:vod: 123`.

Empfohlen:

* Live: `xtream:live:{id}`
* Vod: `xtream:vod:{id}`
* Series: `xtream:series:{id}`
* Episode (wenn stabil): `xtream:episode:{episodeId}`
* Episode fallback (nur wenn n√∂tig):
  `xtream:episode:series:{seriesId}:s{season}:e{episode}`
  (alles klein, konsistent, keine Whitespace, keine Nebenformate)

### XtreamIdCodec (Single Source of Truth)

```kotlin
class XtreamIdCodec : SourceIdCodec {
  override val sourceType = SourceType("xtream")

  override fun parse(raw: String): ParsedSourceId? {
    if (!raw.startsWith("xtream:")) return null

    val parts = raw.split(':')
    if (parts.size < 3) return null

    return when (parts[1]) {
      "live" -> parts.getOrNull(2)?.toLongOrNull()?.let { ParsedSourceId.LiveChannel(it) }
      "vod" -> parts.getOrNull(2)?.toLongOrNull()?.let { ParsedSourceId.Vod(it) }
      "series" -> parts.getOrNull(2)?.toLongOrNull()?.let { ParsedSourceId.Series(it) }
      "episode" -> parseEpisode(parts)
      else -> null
    }
  }

  override fun format(parsed: ParsedSourceId): SourceId {
    val s = when (parsed) {
      is ParsedSourceId.LiveChannel -> "xtream:live:${parsed.channelId}"
      is ParsedSourceId.Vod -> "xtream:vod:${parsed.vodId}"
      is ParsedSourceId.Series -> "xtream:series:${parsed.seriesId}"
      is ParsedSourceId.Episode -> formatEpisode(parsed)
    }
    return SourceId(s)
  }

  private fun parseEpisode(parts: List<String>): ParsedSourceId? {
    // A) xtream:episode:<episodeId>
    if (parts.size == 3) {
      return parts[2].toLongOrNull()?.let { ParsedSourceId.Episode(episodeId = it) }
    }

    // B) xtream:episode:series:<seriesId>:s<season>:e<episode>
    if (parts.size == 6 && parts[2] == "series") {
      val seriesId = parts[3].toLongOrNull() ?: return null
      val season = parts[4].removePrefix("s").toIntOrNull() ?: return null
      val ep = parts[5].removePrefix("e").toIntOrNull() ?: return null
      return ParsedSourceId.Episode(seriesId = seriesId, season = season, episode = ep)
    }

    return null
  }

  private fun formatEpisode(p: ParsedSourceId.Episode): String {
    p.episodeId?.let { return "xtream:episode:$it" }
    val seriesId = requireNotNull(p.seriesId) { "seriesId required when episodeId missing" }
    val season = requireNotNull(p.season) { "season required when episodeId missing" }
    val ep = requireNotNull(p.episode) { "episode required when episodeId missing" }
    return "xtream:episode:series:$seriesId:s$season:e$ep"
  }
}
```

Damit existieren Xtream-ID-Formate exakt **an einer Stelle**.

---

## 4) Codec √ºberall nutzen (keine `removePrefix(...)` mehr)

* **Pipeline**: keine hardcodierten Strings, sondern `codec.format(...)`.
* **Playback**: `codec.parse(context.sourceId.value)` ‚Üí `when(parsed)` ‚Üí URL bauen.
* **Data/Repos**: DB speichert Strings, aber Zugriff/Interpretation l√§uft √ºber `codec.parse(...)`.

---

## 5) Zentraler Registry/Resolver (f√ºr zuk√ºnftige Sources)

Damit neue Sources plug-in-artig rein k√∂nnen:

```kotlin
interface SourceIdRegistry {
  fun parse(sourceId: SourceId): Pair<SourceType, ParsedSourceId>?
}

class DefaultSourceIdRegistry(
  private val codecs: Set<@JvmSuppressWildcards SourceIdCodec>
) : SourceIdRegistry {

  override fun parse(sourceId: SourceId): Pair<SourceType, ParsedSourceId>? {
    val raw = sourceId.value
    for (c in codecs) {
      val parsed = c.parse(raw) ?: continue
      return c.sourceType to parsed
    }
    return null
  }
}
```

DI: `@IntoSet` je Codec (Xtream jetzt, weitere Sources sp√§ter).
Generator-Perspektive: neue Source = neuer Codec + Bindings.

---

## 6) Migration & Guardrails

### A) Lenient Parse nur f√ºr Migration

Falls bereits alte IDs in DB liegen (z.B. mit Whitespace), erlaubt der Migration-Code das kurzfristig ‚Äì **format() bleibt strict**.

### B) Einmaliger Migration Worker/Script

* scan Entities
* parse lenient
* re-format strict
* update

### C) CI Guardrails

* Fail, wenn Pattern `xtream:vod: ` (Whitespace) auftaucht.
* Fail, wenn `removePrefix("xtream:")` au√üerhalb `core:ids` verwendet wird.

Ihr habt bereits CI-Scripts in `scripts/ci/‚Ä¶` ‚Äì das passt perfekt.

---

## 7) Warum das ‚Äûperfekt‚Äú zu euren Zielen passt

* **Platin**: eliminiert die h√§ufigsten ‚ÄûDetail/Resume/Playback manchmal kaputt‚Äú-Bugs.
* **Source-Agnostik**: App kennt keine Source-Stringformate mehr, nur typed IDs + Codec.
* **Generator-ready**: neue Source = Codec + DI + Tests.
* **Source-Vorteile bleiben m√∂glich**: EpisodeId vs Composite-Fallback kann source-spezifisch korrekt abgebildet werden, ohne UI/Player zu verbiegen.

---

## Copilot/Codex Task (English, precise)

```text
Create a new module core:ids and implement a typed, centralized SourceId system.

Requirements:
1) Add @JvmInline wrappers in core:model: SourceId(String), SourceType(String), optional CanonicalId(String).
2) Create core:ids with:
   - sealed class ParsedSourceId (LiveChannel, Vod, Series, Episode)
   - interface SourceIdCodec { sourceType, parse(raw): ParsedSourceId?, format(parsed): SourceId }
   - DefaultSourceIdRegistry consuming Set<SourceIdCodec> via DI (@IntoSet)
3) Implement XtreamIdCodec with ONE strict format:
   - xtream:live:<id>
   - xtream:vod:<id>
   - xtream:series:<id>
   - xtream:episode:<episodeId>
   - fallback only: xtream:episode:series:<seriesId>:s<season>:e<episode>
   Formatting must not contain whitespace.
4) Replace all hardcoded Xtream sourceId string building and removePrefix parsing in:
   - pipeline/xtream (mappers/extensions)
   - playback/xtream (source factory)
   - infra/data-nx xtream repos (where applicable)
   Use XtreamIdCodec.format/parse instead.
5) Add tests:
   - XtreamIdCodecRoundTripTest (format -> parse -> format stable)
   - XtreamIdCodecRejectsWhitespaceTest
   - MigrationLenientParseTest (if legacy whitespace exists) plus a one-off migration worker or script to rewrite stored IDs.
6) Add CI/guardrails:
   - fail build if pattern 'xtream:vod: ' or 'removePrefix("xtream:' occurs outside core:ids.
Keep player source-agnostic; no changes to player/internal are allowed.
```

