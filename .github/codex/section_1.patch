diff --git a/app/src/main/java/com/chris/m3usuite/player/SeekPressAnalyzer.kt b/app/src/main/java/com/chris/m3usuite/player/SeekPressAnalyzer.kt
new file mode 100644
index 0000000..b9b1b3d
--- /dev/null
+++ b/app/src/main/java/com/chris/m3usuite/player/SeekPressAnalyzer.kt
@@ -0,0 +1,131 @@
+package com.chris.m3usuite.player
+
+import android.os.SystemClock
+
+/**
+ * SeekPressAnalyzer implements a simple press multiplier for DPAD-based seeking.
+ *
+ * Rules
+ * - Single-press: step = singleMs (default 30s)
+ * - Double-press (<= doubleWindowMs since previous press): step = doubleMs (default 2m)
+ * - Triple-press (<= tripleWindowMs total since first press): step = tripleMs (default 10m)
+ * - Long-press auto-repeat should use the current step (single/double/triple) until the sequence resets.
+ *
+ * Sequence resets when the time since the last press exceeds [tripleWindowMs] (new sequence starts).
+ * We don't retroactively correct previously applied steps; instead, we escalate the step-size for
+ * subsequent repeats/presses within the time windows.
+ */
+data class SeekPressConfig(
+    val singleMs: Long = 30_000L,
+    val doubleMs: Long = 120_000L,
+    val tripleMs: Long = 600_000L,
+    val doubleWindowMs: Long = 350L,
+    val tripleWindowMs: Long = 500L
+)
+
+class SeekPressAnalyzer(
+    private val cfg: SeekPressConfig = SeekPressConfig()
+) {
+    private var firstAt: Long = 0L
+    private var lastAt: Long = 0L
+    private var count: Int = 0
+    private var currentStepMs: Long = cfg.singleMs
+
+    /**
+     * Records a press at [nowMs] and returns the step to apply for this press.
+     * Escalates current step (single→double→triple) based on timing.
+     */
+    @Synchronized
+    fun recordPress(nowMs: Long = SystemClock.elapsedRealtime()): Long {
+        if (count == 0 || nowMs - lastAt > cfg.tripleWindowMs) {
+            // New sequence
+            firstAt = nowMs
+            lastAt = nowMs
+            count = 1
+            currentStepMs = cfg.singleMs
+            return currentStepMs
+        }
+        // Still within an active sequence
+        return when (count) {
+            1 -> {
+                if (nowMs - lastAt <= cfg.doubleWindowMs) {
+                    // Double press detected
+                    count = 2
+                    lastAt = nowMs
+                    currentStepMs = cfg.doubleMs
+                    currentStepMs
+                } else {
+                    // Not within double window → start a new sequence
+                    firstAt = nowMs
+                    lastAt = nowMs
+                    count = 1
+                    currentStepMs = cfg.singleMs
+                    currentStepMs
+                }
+            }
+            2 -> {
+                // Third press qualifies as triple when total window from first press fits
+                if (nowMs - firstAt <= cfg.tripleWindowMs) {
+                    count = 3
+                    lastAt = nowMs
+                    currentStepMs = cfg.tripleMs
+                    currentStepMs
+                } else {
+                    // Too late → new sequence
+                    firstAt = nowMs
+                    lastAt = nowMs
+                    count = 1
+                    currentStepMs = cfg.singleMs
+                    currentStepMs
+                }
+            }
+            else -> {
+                // Already triple or more → keep using current step in this burst
+                lastAt = nowMs
+                currentStepMs
+            }
+        }
+    }
+
+    /**
+     * Returns the step to use for auto-repeat while the key is held.
+     * Callers should reset the sequence when releasing the key or when timing out.
+     */
+    @Synchronized
+    fun repeatStepMs(): Long = currentStepMs
+
+    /**
+     * Resets the current burst (e.g., after timeout, PLAY/OK, or key up).
+     */
+    @Synchronized
+    fun reset() {
+        firstAt = 0L
+        lastAt = 0L
+        count = 0
+        currentStepMs = cfg.singleMs
+    }
+}
