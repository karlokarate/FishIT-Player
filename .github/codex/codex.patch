diff --git a/app/src/main/java/com/chris/m3usuite/player/SeekPressAnalyzer.kt b/app/src/main/java/com/chris/m3usuite/player/SeekPressAnalyzer.kt
new file mode 100644
index 0000000..b9b1b3d
--- /dev/null
+++ b/app/src/main/java/com/chris/m3usuite/player/SeekPressAnalyzer.kt
@@ -0,0 +1,131 @@
+package com.chris.m3usuite.player
+
+import android.os.SystemClock
+
+/**
+ * SeekPressAnalyzer implements a simple press multiplier for DPAD-based seeking.
+ *
+ * Rules
+ * - Single-press: step = singleMs (default 30s)
+ * - Double-press (<= doubleWindowMs since previous press): step = doubleMs (default 2m)
+ * - Triple-press (<= tripleWindowMs total since first press): step = tripleMs (default 10m)
+ * - Long-press auto-repeat should use the current step (single/double/triple) until the sequence resets.
+ *
+ * Sequence resets when the time since the last press exceeds [tripleWindowMs] (new sequence starts).
+ * We don't retroactively correct previously applied steps; instead, we escalate the step-size for
+ * subsequent repeats/presses within the time windows.
+ */
+data class SeekPressConfig(
+    val singleMs: Long = 30_000L,
+    val doubleMs: Long = 120_000L,
+    val tripleMs: Long = 600_000L,
+    val doubleWindowMs: Long = 350L,
+    val tripleWindowMs: Long = 500L
+)
+
+class SeekPressAnalyzer(
+    private val cfg: SeekPressConfig = SeekPressConfig()
+) {
+    private var firstAt: Long = 0L
+    private var lastAt: Long = 0L
+    private var count: Int = 0
+    private var currentStepMs: Long = cfg.singleMs
+
+    /**
+     * Records a press at [nowMs] and returns the step to apply for this press.
+     * Escalates current step (single→double→triple) based on timing.
+     */
+    @Synchronized
+    fun recordPress(nowMs: Long = SystemClock.elapsedRealtime()): Long {
+        if (count == 0 || nowMs - lastAt > cfg.tripleWindowMs) {
+            // New sequence
+            firstAt = nowMs
+            lastAt = nowMs
+            count = 1
+            currentStepMs = cfg.singleMs
+            return currentStepMs
+        }
+        // Still within an active sequence
+        return when (count) {
+            1 -> {
+                if (nowMs - lastAt <= cfg.doubleWindowMs) {
+                    // Double press detected
+                    count = 2
+                    lastAt = nowMs
+                    currentStepMs = cfg.doubleMs
+                    currentStepMs
+                } else {
+                    // Not within double window → start a new sequence
+                    firstAt = nowMs
+                    lastAt = nowMs
+                    count = 1
+                    currentStepMs = cfg.singleMs
+                    currentStepMs
+                }
+            }
+            2 -> {
+                // Third press qualifies as triple when total window from first press fits
+                if (nowMs - firstAt <= cfg.tripleWindowMs) {
+                    count = 3
+                    lastAt = nowMs
+                    currentStepMs = cfg.tripleMs
+                    currentStepMs
+                } else {
+                    // Too late → new sequence
+                    firstAt = nowMs
+                    lastAt = nowMs
+                    count = 1
+                    currentStepMs = cfg.singleMs
+                    currentStepMs
+                }
+            }
+            else -> {
+                // Already triple or more → keep using current step in this burst
+                lastAt = nowMs
+                currentStepMs
+            }
+        }
+    }
+
+    /**
+     * Returns the step to use for auto-repeat while the key is held.
+     * Callers should reset the sequence when releasing the key or when timing out.
+     */
+    @Synchronized
+    fun repeatStepMs(): Long = currentStepMs
+
+    /**
+     * Resets the current burst (e.g., after timeout, PLAY/OK, or key up).
+     */
+    @Synchronized
+    fun reset() {
+        firstAt = 0L
+        lastAt = 0L
+        count = 0
+        currentStepMs = cfg.singleMs
+    }
+}
diff --git a/app/src/test/java/com/chris/m3usuite/player/SeekPressAnalyzerTest.kt b/app/src/test/java/com/chris/m3usuite/player/SeekPressAnalyzerTest.kt
new file mode 100644
index 0000000..bb5f567
--- /dev/null
+++ b/app/src/test/java/com/chris/m3usuite/player/SeekPressAnalyzerTest.kt
@@ -0,0 +1,85 @@
+package com.chris.m3usuite.player
+
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertTrue
+import org.junit.Test
+
+class SeekPressAnalyzerTest {
+
+    @Test
+    fun singlePress_defaultsTo30s() {
+        val a = SeekPressAnalyzer()
+        val step = a.recordPress(nowMs = 0L)
+        assertEquals(30_000L, step)
+        // Auto-repeat uses same step
+        assertEquals(30_000L, a.repeatStepMs())
+    }
+
+    @Test
+    fun doublePress_withinWindow_escalatesTo2m() {
+        val a = SeekPressAnalyzer()
+        // First
+        assertEquals(30_000L, a.recordPress(nowMs = 0L))
+        // Second within 300ms (<=350)
+        val step2 = a.recordPress(nowMs = 300L)
+        assertEquals(120_000L, step2)
+        // Auto-repeat uses 2m
+        assertEquals(120_000L, a.repeatStepMs())
+    }
+
+    @Test
+    fun triplePress_withinTotalWindow_escalatesTo10m() {
+        val a = SeekPressAnalyzer()
+        // First at 0ms
+        assertEquals(30_000L, a.recordPress(nowMs = 0L))
+        // Second at 300ms
+        assertEquals(120_000L, a.recordPress(nowMs = 300L))
+        // Third at 480ms total -> within 500ms triple window
+        val step3 = a.recordPress(nowMs = 480L)
+        assertEquals(600_000L, step3)
+        // Auto-repeat stays 10m
+        assertEquals(600_000L, a.repeatStepMs())
+    }
+
+    @Test
+    fun outsideWindows_resetsSequence() {
+        val a = SeekPressAnalyzer()
+        // First
+        assertEquals(30_000L, a.recordPress(nowMs = 0L))
+        // Second after 600ms (>350) → new sequence, single again
+        assertEquals(30_000L, a.recordPress(nowMs = 600L))
+        // Third after additional 600ms (>500 since last first) → still single
+        assertEquals(30_000L, a.recordPress(nowMs = 1200L))
+    }
+
+    @Test
+    fun reset_restoresSingleStep() {
+        val a = SeekPressAnalyzer()
+        // Escalate to triple
+        a.recordPress(nowMs = 0L)
+        a.recordPress(nowMs = 300L)
+        a.recordPress(nowMs = 480L)
+        assertEquals(600_000L, a.repeatStepMs())
+        a.reset()
+        assertEquals(30_000L, a.repeatStepMs())
+        assertEquals(30_000L, a.recordPress(nowMs = 2000L))
+    }
+}
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 5a77828..f7dc1b1 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,10 @@
+2025-09-29
+- feat(player/seek): introduce DPAD seek press-multiplier logic with unit tests. A new helper `SeekPressAnalyzer` computes step sizes for single/double/triple presses (30s/2m/10m) within 350ms/500ms windows and exposes a stable repeat step for long-press auto-repeat. This is the foundation for TV seek behavior; UI wiring uses this helper to keep controls responsive on Fire TV.
+  - tests: add `SeekPressAnalyzerTest` covering single/double/triple detection, window boundaries, and reset behavior.
+
+Note: UI slider focus/DPAD integration is aligned with this logic and will hook the analyzer into InternalPlayerScreen’s seekbar to move the thumb via LEFT/RIGHT and commit with OK/ENTER. Long‑press auto‑repeat will reuse the current step.
+
 2025-09-27
 - fix(manifest/icon): set application icon to `@mipmap/ic_launcher` and add `android:roundIcon` (`@mipmap/ic_launcher_round`) instead of the missing `@drawable/fisch_bg`. Launcher already uses adaptive mipmaps; this aligns the manifest with actual assets.
 - docs(roadmap): Priorität‑1 Tasks für TV Fokus/DPAD vereinheitlicht: alle horizontalen Container → TvFocusRow (inkl. Chips/Carousels), alle interaktiven Elemente → tvClickable/tvFocusableItem (No‑Op auf Phone), zentrale Scroll+Fokus‑Registry (ScrollStateRegistry), einheitliche Auto‑Collapse/Expand‑Trigger im HomeChromeScaffold, kein onPreviewKeyEvent außer echten Sonderfällen, Audit‑Skript erzwingt Regeln.
