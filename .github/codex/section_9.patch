diff --git a/app/src/main/java/com/chris/m3usuite/ui/screens/PlaylistSetupScreen.kt b/app/src/main/java/com/chris/m3usuite/ui/screens/PlaylistSetupScreen.kt
index 45c4c22..bdabf36 100644
--- a/app/src/main/java/com/chris/m3usuite/ui/screens/PlaylistSetupScreen.kt
+++ b/app/src/main/java/com/chris/m3usuite/ui/screens/PlaylistSetupScreen.kt
@@ -28,6 +28,7 @@ import androidx.compose.runtime.*
 import androidx.compose.runtime.saveable.rememberSaveable
 import androidx.compose.ui.Alignment
 import androidx.compose.ui.Modifier
+import androidx.compose.ui.draw.alpha
 import androidx.compose.ui.graphics.Brush
 import androidx.compose.ui.graphics.Color
 import androidx.compose.ui.platform.LocalContext
@@ -52,6 +53,9 @@ import okhttp3.HttpUrl.Companion.toHttpUrlOrNull
 
 import com.chris.m3usuite.BuildConfig
 import com.chris.m3usuite.prefs.SettingsStore
+import com.chris.m3usuite.ui.forms.TvButtonRow
+import com.chris.m3usuite.ui.forms.TvFormSection
+import com.chris.m3usuite.ui.forms.TvTextFieldRow
 import com.chris.m3usuite.work.SchedulingGateway
 import com.chris.m3usuite.backup.QuickImportRow
 import com.chris.m3usuite.ui.common.AccentCard
@@ -63,6 +67,7 @@ import com.chris.m3usuite.core.xtream.XtreamDetect
 import com.chris.m3usuite.core.xtream.XtreamSeeder
 
 // Setup mode for first-run screen (top-level enum; local enums are not allowed)
 enum class SetupMode { M3U, XTREAM }
@@ -81,6 +86,7 @@ fun PlaylistSetupScreen(onDone: () -> Unit) {
         com.chris.m3usuite.core.debug.GlobalDebug.logTree("setup:root")
     }
     val focusManager = LocalFocusManager.current
+    val isTv = com.chris.m3usuite.ui.skin.isTvDevice(ctx)
 
     // Deep-Link (VIEW-Intent) als Initialwert
     val initialLink by remember {
@@ -141,6 +147,10 @@ fun PlaylistSetupScreen(onDone: () -> Unit) {
         }
     }
 
+    // Feature-flagged TV Forms (v1) – early return path
+    val useTvForms = remember { BuildConfig.FEATURE_TV_FORMS_V1 && isTv }
+    if (useTvForms) { TvSetupFormContent(onDone = onDone, store = store, snackbar = snackbar) ; return }
+
     // -------- Validation / Normalization --------
     val isM3uOk by remember(m3u) {
         derivedStateOf {
@@ -191,6 +201,146 @@ fun PlaylistSetupScreen(onDone: () -> Unit) {
     val bgV = remember(cs) {
         Brush.verticalGradient(
 
+// TV Forms v1: Minimal, DPAD-friendly setup section used when FEATURE_TV_FORMS_V1 && TV
+@Composable
+private fun TvSetupFormContent(
+    onDone: () -> Unit,
+    store: SettingsStore,
+    snackbar: SnackbarHostState
+) {
+    val ctx = LocalContext.current
+    val scope = rememberCoroutineScope()
+    var mode by rememberSaveable { mutableStateOf(SetupMode.M3U) }
+    var busy by rememberSaveable { mutableStateOf(false) }
+    var inlineMsg by rememberSaveable { mutableStateOf<String?>(null) }
+
+    // Fields (simple strings for TV form)
+    var m3u by rememberSaveable { mutableStateOf("") }
+    var epg by rememberSaveable { mutableStateOf("") }
+    var ua by rememberSaveable { mutableStateOf("IBOPlayer/1.4 (Android)") }
+    var ref by rememberSaveable { mutableStateOf("") }
+
+    var xtHost by rememberSaveable { mutableStateOf("") }
+    var xtHttps by rememberSaveable { mutableStateOf(false) }
+    var xtPort by rememberSaveable { mutableStateOf("80") }
+    var xtUser by rememberSaveable { mutableStateOf("") }
+    var xtPass by rememberSaveable { mutableStateOf("") }
+    var xtOut by rememberSaveable { mutableStateOf("m3u8") }
+
+    // Prefill from Settings
+    LaunchedEffect(Unit) {
+        runCatching {
+            val snap = store.snapshot()
+            m3u = snap.m3uUrl
+            epg = snap.epgUrl
+            ua = snap.userAgent.ifBlank { ua }
+            ref = snap.referer
+            xtHost = snap.xtHost
+            xtHttps = snap.xtPort == 443
+            xtPort = snap.xtPort.toString()
+            xtUser = snap.xtUser
+            xtPass = snap.xtPass
+            xtOut = snap.xtOutput.ifBlank { "m3u8" }
+        }
+    }
+
+    // Validation
+    val isM3uOk by remember(m3u) {
+        derivedStateOf {
+            val u = m3u.trim().toHttpUrlOrNull()
+            u != null && (u.scheme == "http" || u.scheme == "https")
+        }
+    }
+    val isXtHostValid by remember(xtHost) {
+        derivedStateOf { xtHost.trim().isNotBlank() }
+    }
+    val isXtPortValid by remember(xtPort, xtHttps) {
+        derivedStateOf {
+            val p = xtPort.trim().toIntOrNull() ?: return@derivedStateOf false
+            p in 1..65535 && (!(xtHttps) || p != 80)
+        }
+    }
+    val isXtCredsOk by remember(xtUser, xtPass) {
+        derivedStateOf { xtUser.isNotBlank() && xtPass.isNotBlank() }
+    }
+    val isXtOutValid by remember(xtOut) {
+        derivedStateOf { xtOut.trim().isNotBlank() }
+    }
+    val canSubmit by remember(mode, isM3uOk, isXtHostValid, isXtPortValid, isXtCredsOk, isXtOutValid, busy) {
+        derivedStateOf {
+            !busy && when (mode) {
+                SetupMode.M3U -> isM3uOk
+                SetupMode.XTREAM -> isXtHostValid && isXtPortValid && isXtCredsOk && isXtOutValid
+            }
+        }
+    }
+
+    fun m3uErrors(): String? = if (!isM3uOk) "Bitte gültige M3U-URL angeben (http/https)" else null
+    fun xtHostErr(): String? = if (!isXtHostValid) "Host ist erforderlich" else null
+    fun xtPortErr(): String? = if (!isXtPortValid) "Port ungültig" else null
+    fun xtCredErr(): String? = if (!isXtCredsOk) "Benutzername und Passwort erforderlich" else null
+    fun xtOutErr(): String? = if (!isXtOutValid) "Ausgabeformat erforderlich" else null
+
+    suspend fun doSubmit() {
+        busy = true
+        inlineMsg = null
+        try {
+            when (mode) {
+                SetupMode.M3U -> {
+                    val m = m3u.trim()
+                    val e = epg.trim()
+                    val u = ua.trim()
+                    val r = ref.trim()
+                    store.set(com.chris.m3usuite.prefs.Keys.M3U_URL, m)
+                    store.set(com.chris.m3usuite.prefs.Keys.EPG_URL, e)
+                    if (u.isNotBlank()) store.set(com.chris.m3usuite.prefs.Keys.USER_AGENT, u)
+                    if (r.isNotBlank()) store.set(com.chris.m3usuite.prefs.Keys.REFERER, r)
+                }
+                SetupMode.XTREAM -> {
+                    val host = run {
+                        val raw = xtHost.trim()
+                        val ensureScheme = if (raw.contains("://")) raw else "http://$raw"
+                        val u = ensureScheme.toHttpUrlOrNull()
+                        (u?.host ?: raw.substringBefore('/').substringBefore(':')).trim()
+                    }
+                    val port = xtPort.trim().toIntOrNull() ?: if (xtHttps) 443 else 80
+                    store.setXtHost(host)
+                    store.setXtPort(port)
+                    store.setXtUser(xtUser.trim())
+                    store.setXtPass(xtPass.trim())
+                    store.setXtOutput(xtOut.trim())
+                    store.setXtPortVerified(true)
+                }
+            }
+            snackbar.showSnackbar("Einstellungen gespeichert")
+            onDone()
+        } catch (t: Throwable) {
+            inlineMsg = t.message ?: "Fehler beim Speichern"
+        } finally {
+            busy = false
+        }
+    }
+
+    Column(Modifier.fillMaxSize().padding(16.dp), verticalArrangement = Arrangement.spacedBy(12.dp)) {
+        TvFormSection(title = "Setup") {
+            TvSelectRow(
+                label = "Modus",
+                options = listOf(SetupMode.M3U, SetupMode.XTREAM),
+                selected = mode,
+                onSelected = { mode = it },
+                optionLabel = { if (it == SetupMode.M3U) "M3U" else "Xtream" }
+            )
+        }
+        if (mode == SetupMode.M3U) {
+            TvFormSection(title = "M3U", description = "Playlist- und EPG-URL") {
+                TvTextFieldRow("M3U URL", m3u, onValueChange = { m3u = it }, placeholder = "http(s)://…/get.php?…", errorText = m3uErrors())
+                TvTextFieldRow("EPG URL", epg, onValueChange = { epg = it }, placeholder = "http(s)://…/xmltv.php?…")
+                TvTextFieldRow("User-Agent", ua, onValueChange = { ua = it })
+                TvTextFieldRow("Referer", ref, onValueChange = { ref = it })
+            }
+        } else {
+            TvFormSection(title = "Xtream", description = "Portal-Zugangsdaten") {
+                TvTextFieldRow("Host", xtHost, onValueChange = { xtHost = it }, placeholder = "example.com", errorText = xtHostErr())
+                TvTextFieldRow("Port", xtPort, onValueChange = { xtPort = it }, placeholder = if (xtHttps) "443" else "80", errorText = xtPortErr())
+                com.chris.m3usuite.ui.forms.TvSwitchRow(label = "HTTPS", checked = xtHttps, onCheckedChange = { xtHttps = it })
+                TvTextFieldRow("Benutzer", xtUser, onValueChange = { xtUser = it }, errorText = xtCredErr())
+                TvTextFieldRow("Passwort", xtPass, onValueChange = { xtPass = it }, keyboard = com.chris.m3usuite.ui.forms.TvKeyboard.Password, errorText = xtCredErr())
+                TvTextFieldRow("Ausgabe", xtOut, onValueChange = { xtOut = it }, placeholder = "m3u8|ts", errorText = xtOutErr())
+            }
+        }
+        if (!inlineMsg.isNullOrBlank()) {
+            Text(text = inlineMsg!!, color = MaterialTheme.colorScheme.error, modifier = Modifier.alpha(0.9f))
+        }
+        TvButtonRow(
+            primaryText = if (busy) "Bitte warten…" else "Speichern",
+            onPrimary = { if (!busy) scope.launch { doSubmit() } },
+            secondaryText = "Abbrechen",
+            onSecondary = { if (!busy) onDone() },
+            enabled = canSubmit
+        )
+    }
+}
+
